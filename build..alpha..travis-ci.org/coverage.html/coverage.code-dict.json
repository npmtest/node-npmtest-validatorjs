{"/home/travis/build/npmtest/node-npmtest-validatorjs/test.js":"/* istanbul instrument in package npmtest_validatorjs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-validatorjs/lib.npmtest_validatorjs.js":"/* istanbul instrument in package npmtest_validatorjs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_validatorjs = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_validatorjs = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-validatorjs/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-validatorjs && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_validatorjs */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_validatorjs\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_validatorjs.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_validatorjs.rollup.js'] =\n            local.assetsDict['/assets.npmtest_validatorjs.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_validatorjs.__dirname + '/lib.npmtest_validatorjs.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/src/validator.js":"var Rules = require('./rules');\nvar Lang = require('./lang');\nvar Errors = require('./errors');\nvar Attributes = require('./attributes');\nvar AsyncResolvers = require('./async');\n\nvar Validator = function(input, rules, customMessages) {\n  var lang = Validator.getDefaultLang();\n  this.input = input;\n\n  this.messages = Lang._make(lang);\n  this.messages._setCustom(customMessages);\n  this.setAttributeFormatter(Validator.prototype.attributeFormatter);\n\n  this.errors = new Errors();\n  this.errorCount = 0;\n\n  this.hasAsync = false;\n  this.rules = this._parseRules(rules);\n};\n\nValidator.prototype = {\n\n  constructor: Validator,\n\n  /**\n   * Default language\n   *\n   * @type {string}\n   */\n  lang: 'en',\n\n  /**\n   * Numeric based rules\n   *\n   * @type {array}\n   */\n  numericRules: ['integer', 'numeric'],\n\n  /**\n   * Attribute formatter.\n   *\n   * @type {function}\n   */\n  attributeFormatter: Attributes.formatter,\n\n  /**\n   * Run validator\n   *\n   * @return {boolean} Whether it passes; true = passes, false = fails\n   */\n  check: function() {\n    var self = this;\n\n    for (var attribute in this.rules) {\n      var attributeRules = this.rules[attribute];\n      var inputValue = this._objectPath(this.input, attribute);\n\n      if (this._hasRule(attribute, ['sometimes']) && !this._suppliedWithData(attribute)) {\n        continue;\n      }\n\n      for (var i = 0, len = attributeRules.length, rule, ruleOptions, rulePassed; i < len; i++) {\n        ruleOptions = attributeRules[i];\n        rule = this.getRule(ruleOptions.name);\n\n        if (!this._isValidatable(rule, inputValue)) {\n          continue;\n        }\n\n        rulePassed = rule.validate(inputValue, ruleOptions.value, attribute);\n        if (!rulePassed) {\n          this._addFailure(rule);\n        }\n\n        if (this._shouldStopValidating(attribute, rulePassed)) {\n          break;\n        }\n      }\n    }\n\n    return this.errorCount === 0;\n  },\n\n  /**\n   * Run async validator\n   *\n   * @param {function} passes\n   * @param {function} fails\n   * @return {void}\n   */\n  checkAsync: function(passes, fails) {\n    var _this = this;\n    passes = passes || function() {};\n    fails = fails || function() {};\n\n    var failsOne = function(rule, message) {\n      _this._addFailure(rule, message);\n    };\n\n    var resolvedAll = function(allPassed) {\n      if (allPassed) {\n        passes();\n      } else {\n        fails();\n      }\n    };\n\n    var asyncResolvers = new AsyncResolvers(failsOne, resolvedAll);\n\n    var validateRule = function(inputValue, ruleOptions, attribute, rule) {\n      return function() {\n        var resolverIndex = asyncResolvers.add(rule);\n        rule.validate(inputValue, ruleOptions.value, attribute, function() {\n          asyncResolvers.resolve(resolverIndex);\n        });\n      };\n    };\n\n    for (var attribute in this.rules) {\n      var attributeRules = this.rules[attribute];\n      var inputValue = this._objectPath(this.input, attribute);\n\n      if (this._hasRule(attribute, ['sometimes']) && !this._suppliedWithData(attribute)) {\n        continue;\n      }\n\n      for (var i = 0, len = attributeRules.length, rule, ruleOptions; i < len; i++) {\n        ruleOptions = attributeRules[i];\n\n        rule = this.getRule(ruleOptions.name);\n\n        if (!this._isValidatable(rule, inputValue)) {\n          continue;\n        }\n\n        validateRule(inputValue, ruleOptions, attribute, rule)();\n      }\n    }\n\n    asyncResolvers.enableFiring();\n    asyncResolvers.fire();\n  },\n\n  /**\n   * Add failure and error message for given rule\n   *\n   * @param {Rule} rule\n   */\n  _addFailure: function(rule) {\n    var msg = this.messages.render(rule);\n    this.errors.add(rule.attribute, msg);\n    this.errorCount++;\n  },\n\n  /**\n   * Flatten nested object, normalizing { foo: { bar: 1 } } into: { 'foo.bar': 1 }\n   *\n   * @param  {object} nested object\n   * @return {object} flattened object\n   */\n  _flattenObject: function (obj) {\n    var flattened = {};\n    function recurse (current, property) {\n      if (!property && Object.getOwnPropertyNames(current).length === 0) {\n        return;\n      }\n      if (Object(current) !== current || Array.isArray(current)) {\n        flattened[property] = current;\n      } else {\n        var isEmpty = true;\n        for (var p in current) {\n          isEmpty = false;\n          recurse(current[p], property ? property + \".\" + p : p);\n        }\n        if (isEmpty) {\n          flattened[property] = {};\n        }\n      }\n    }\n    if (obj) {\n      recurse(obj);\n    }\n    return flattened;\n  },\n\n  /**\n   * Extract value from nested object using string path with dot notation\n   *\n   * @param  {object} object to search in\n   * @param  {string} path inside object\n   * @return {any|void} value under the path\n   */\n  _objectPath: function (obj, path) {\n    if (Object.prototype.hasOwnProperty.call(obj, path)) {\n      return obj[path];\n    }\n\n    var keys = path.replace(/\\[(\\w+)\\]/g, \".$1\").replace(/^\\./, \"\").split(\".\");\n    var copy = {};\n\n    for (var attr in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, attr)) {\n        copy[attr] = obj[attr];\n      }\n    }\n\n    for (var i = 0, l = keys.length; i < l; i++) {\n      if (Object.hasOwnProperty.call(copy, keys[i])) {\n        copy = copy[keys[i]];\n      } else {\n        return;\n      }\n    }\n    return copy;\n  },\n\n  /**\n   * Parse rules, normalizing format into: { attribute: [{ name: 'age', value: 3 }] }\n   *\n   * @param  {object} rules\n   * @return {object}\n   */\n  _parseRules: function(rules) {\n    var parsedRules = {};\n    rules = this._flattenObject(rules);\n    for (var attribute in rules) {\n      var rulesArray = rules[attribute];\n      var attributeRules = [];\n\n      if (typeof rulesArray === 'string') {\n        rulesArray = rulesArray.split('|');\n      }\n\n      for (var i = 0, len = rulesArray.length, rule; i < len; i++) {\n        rule = this._extractRuleAndRuleValue(rulesArray[i]);\n        if (Rules.isAsync(rule.name)) {\n          this.hasAsync = true;\n        }\n        attributeRules.push(rule);\n      }\n\n      parsedRules[attribute] = attributeRules;\n    }\n    return parsedRules;\n  },\n\n  /**\n   * Determines if the attribute is supplied with the original data object.\n   *\n   * @param  {array} attribute\n   * @return {boolean}\n   */\n  _suppliedWithData: function(attribute) {\n    return this.input.hasOwnProperty(attribute);\n  },\n\n  /**\n   * Extract a rule and a value from a ruleString (i.e. min:3), rule = min, value = 3\n   *\n   * @param  {string} ruleString min:3\n   * @return {object} object containing the name of the rule and value\n   */\n  _extractRuleAndRuleValue: function(ruleString) {\n    var rule = {},\n      ruleArray;\n\n    rule.name = ruleString;\n\n    if (ruleString.indexOf(':') >= 0) {\n      ruleArray = ruleString.split(':');\n      rule.name = ruleArray[0];\n      rule.value = ruleArray.slice(1).join(\":\");\n    }\n\n    return rule;\n  },\n\n  /**\n   * Determine if attribute has any of the given rules\n   *\n   * @param  {string}  attribute\n   * @param  {array}   findRules\n   * @return {boolean}\n   */\n  _hasRule: function(attribute, findRules) {\n    var rules = this.rules[attribute] || [];\n    for (var i = 0, len = rules.length; i < len; i++) {\n      if (findRules.indexOf(rules[i].name) > -1) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  /**\n   * Determine if attribute has any numeric-based rules.\n   *\n   * @param  {string}  attribute\n   * @return {Boolean}\n   */\n  _hasNumericRule: function(attribute) {\n    return this._hasRule(attribute, this.numericRules);\n  },\n\n  /**\n   * Determine if rule is validatable\n   *\n   * @param  {Rule}   rule\n   * @param  {mixed}  value\n   * @return {boolean}\n   */\n  _isValidatable: function(rule, value) {\n    if (Rules.isImplicit(rule.name)) {\n      return true;\n    }\n\n    return this.getRule('required').validate(value);\n  },\n\n  /**\n   * Determine if we should stop validating.\n   *\n   * @param  {string} attribute\n   * @param  {boolean} rulePassed\n   * @return {boolean}\n   */\n  _shouldStopValidating: function(attribute, rulePassed) {\n\n    var stopOnAttributes = this.stopOnAttributes;\n    if (typeof stopOnAttributes === 'undefined' || stopOnAttributes === false || rulePassed === true) {\n      return false;\n    }\n\n    if (stopOnAttributes instanceof Array) {\n      return stopOnAttributes.indexOf(attribute) > -1;\n    }\n\n    return true;\n  },\n\n  /**\n   * Set custom attribute names.\n   *\n   * @param {object} attributes\n   * @return {void}\n   */\n  setAttributeNames: function(attributes) {\n    this.messages._setAttributeNames(attributes);\n  },\n\n  /**\n   * Set the attribute formatter.\n   *\n   * @param {fuction} func\n   * @return {void}\n   */\n  setAttributeFormatter: function(func) {\n    this.messages._setAttributeFormatter(func);\n  },\n\n  /**\n   * Get validation rule\n   *\n   * @param  {string} name\n   * @return {Rule}\n   */\n  getRule: function(name) {\n    return Rules.make(name, this);\n  },\n\n  /**\n   * Stop on first error.\n   *\n   * @param  {boolean|array} An array of attributes or boolean true/false for all attributes.\n   * @return {void}\n   */\n  stopOnError: function(attributes) {\n    this.stopOnAttributes = attributes;\n  },\n\n  /**\n   * Determine if validation passes\n   *\n   * @param {function} passes\n   * @return {boolean|undefined}\n   */\n  passes: function(passes) {\n    var async = this._checkAsync('passes', passes);\n    if (async) {\n      return this.checkAsync(passes);\n    }\n    return this.check();\n  },\n\n  /**\n   * Determine if validation fails\n   *\n   * @param {function} fails\n   * @return {boolean|undefined}\n   */\n  fails: function(fails) {\n    var async = this._checkAsync('fails', fails);\n    if (async) {\n      return this.checkAsync(function() {}, fails);\n    }\n    return !this.check();\n  },\n\n  /**\n   * Check if validation should be called asynchronously\n   *\n   * @param  {string}   funcName Name of the caller\n   * @param  {function} callback\n   * @return {boolean}\n   */\n  _checkAsync: function(funcName, callback) {\n    var hasCallback = typeof callback === 'function';\n    if (this.hasAsync && !hasCallback) {\n      throw funcName + ' expects a callback when async rules are being tested.';\n    }\n\n    return this.hasAsync || hasCallback;\n  }\n\n};\n\n/**\n * Set messages for language\n *\n * @param {string} lang\n * @param {object} messages\n * @return {this}\n */\nValidator.setMessages = function(lang, messages) {\n  Lang._set(lang, messages);\n  return this;\n};\n\n/**\n * Get messages for given language\n *\n * @param  {string} lang\n * @return {Messages}\n */\nValidator.getMessages = function(lang) {\n  return Lang._get(lang);\n};\n\n/**\n * Set default language to use\n *\n * @param {string} lang\n * @return {void}\n */\nValidator.useLang = function(lang) {\n  this.prototype.lang = lang;\n};\n\n/**\n * Get default language\n *\n * @return {string}\n */\nValidator.getDefaultLang = function() {\n  return this.prototype.lang;\n};\n\n/**\n * Set the attribute formatter.\n *\n * @param {fuction} func\n * @return {void}\n */\nValidator.setAttributeFormatter = function(func) {\n  this.prototype.attributeFormatter = func;\n};\n\n/**\n * Stop on first error.\n *\n * @param  {boolean|array} An array of attributes or boolean true/false for all attributes.\n * @return {void}\n */\nValidator.stopOnError = function(attributes) {\n  this.prototype.stopOnAttributes = attributes;\n};\n\n/**\n * Register custom validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @return {void}\n */\nValidator.register = function(name, fn, message) {\n  var lang = Validator.getDefaultLang();\n  Rules.register(name, fn);\n  Lang._setRuleMessage(lang, name, message);\n};\n\n/**\n * Register asynchronous validation rule\n *\n * @param  {string}   name\n * @param  {function} fn\n * @param  {string}   message\n * @return {void}\n */\nValidator.registerAsync = function(name, fn, message) {\n  var lang = Validator.getDefaultLang();\n  Rules.registerAsync(name, fn);\n  Lang._setRuleMessage(lang, name, message);\n};\n\nmodule.exports = Validator;\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/src/rules.js":"function leapYear(year) {\n  return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0);\n}\n\nfunction isValidDate(inDate) {\n    var valid = true;\n\n    // reformat if supplied as mm.dd.yyyy (period delimiter)\n    if (typeof inDate === 'string') {\n      var pos = inDate.indexOf('.');\n      if ((pos > 0 && pos <= 6)) {\n        inDate = inDate.replace(/\\./g, '-');\n      }\n    }\n\n    var testDate = new Date(inDate);\n    var yr = testDate.getFullYear();\n    var mo = testDate.getMonth() + 1;\n    var day = testDate.getDate();\n\n    var daysInMonth = [31, (leapYear(yr) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n    if (yr < 1000) { return false; }\n    if (isNaN(mo)) { return false; }\n    if (mo > 12) { return false; }\n    if (isNaN(day)) { return false; }\n    if (day > daysInMonth[mo]) { return false; }\n\n    return valid;\n}\n\nvar rules = {\n\n  required: function(val) {\n    var str;\n\n    if (val === undefined || val === null) {\n      return false;\n    }\n\n    str = String(val).replace(/\\s/g, \"\");\n    return str.length > 0 ? true : false;\n  },\n\n  required_if: function(val, req, attribute) {\n    req = this.getParameters();\n    if (this.validator._objectPath(this.validator.input, req[0]) === req[1]) {\n      return this.validator.getRule('required').validate(val);\n    }\n\n    return true;\n  },\n\n  required_unless: function(val, req, attribute) {\n    req = this.getParameters();\n    if (this.validator._objectPath(this.validator.input, req[0]) !== req[1]) {\n      return this.validator.getRule('required').validate(val);\n    }\n\n    return true;\n  },\n\n  required_with: function(val, req, attribute) {\n    if (this.validator._objectPath(this.validator.input, req)) {\n      return this.validator.getRule('required').validate(val);\n    }\n\n    return true;\n  },\n\n  required_with_all: function(val, req, attribute) {\n\n    req = this.getParameters();\n\n    for(var i = 0; i < req.length; i++) {\n      if (!this.validator._objectPath(this.validator.input, req[i])) {\n        return true;\n      }\n    }\n\n    return this.validator.getRule('required').validate(val);\n  },\n\n  required_without: function(val, req, attribute) {\n\n    if (this.validator._objectPath(this.validator.input, req)) {\n      return true;\n    }\n\n    return this.validator.getRule('required').validate(val);\n  },\n\n  required_without_all: function(val, req, attribute) {\n\n    req = this.getParameters();\n\n    for(var i = 0; i < req.length; i++) {\n      if (this.validator._objectPath(this.validator.input, req[i])) {\n        return true;\n      }\n    }\n\n    return this.validator.getRule('required').validate(val);\n  },\n\n  'boolean': function (val) {\n    return (\n      val === true ||\n      val === false ||\n      val === 0 ||\n      val === 1 ||\n      val === '0' ||\n      val === '1' ||\n      val === 'true' ||\n      val === 'false'\n    );\n  },\n\n  // compares the size of strings\n  // with numbers, compares the value\n  size: function(val, req, attribute) {\n    if (val) {\n      req = parseFloat(req);\n\n      var size = this.getSize();\n\n      return size === req;\n    }\n\n    return true;\n  },\n\n  string: function(val, req, attribute) {\n    return typeof val === 'string';\n  },\n\n  sometimes: function(val) {\n    return true;\n  },\n\n  /**\n   * Compares the size of strings or the value of numbers if there is a truthy value\n   */\n  min: function(val, req, attribute) {\n    var size = this.getSize();\n    return size >= req;\n  },\n\n  /**\n   * Compares the size of strings or the value of numbers if there is a truthy value\n   */\n  max: function(val, req, attribute) {\n    var size = this.getSize();\n    return size <= req;\n  },\n\n  between: function(val, req, attribute) {\n    req = this.getParameters();\n    var size = this.getSize();\n    var min = parseFloat(req[0], 10);\n    var max = parseFloat(req[1], 10);\n    return size >= min && size <= max;\n  },\n\n  email: function(val) {\n    var re = /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n    return re.test(val);\n  },\n\n  numeric: function(val) {\n    var num;\n\n    num = Number(val); // tries to convert value to a number. useful if value is coming from form element\n\n    if (typeof num === 'number' && !isNaN(num) && typeof val !== 'boolean') {\n      return true;\n    } else {\n      return false;\n    }\n  },\n\n  array: function(val) {\n    return val instanceof Array;\n  },\n\n  url: function(url) {\n    return (/^https?:\\/\\/\\S+/).test(url);\n  },\n\n  alpha: function(val) {\n    return (/^[a-zA-Z]+$/).test(val);\n  },\n\n  alpha_dash: function(val) {\n    return (/^[a-zA-Z0-9_\\-]+$/).test(val);\n  },\n\n  alpha_num: function(val) {\n    return (/^[a-zA-Z0-9]+$/).test(val);\n  },\n\n  same: function(val, req) {\n    var val1 = this.validator.input[req];\n    var val2 = val;\n\n    if (val1 === val2) {\n      return true;\n    }\n\n    return false;\n  },\n\n  different: function(val, req) {\n    var val1 = this.validator.input[req];\n    var val2 = val;\n\n    if (val1 !== val2) {\n      return true;\n    }\n\n    return false;\n  },\n\n  \"in\": function(val, req) {\n    var list, i;\n\n    if (val) {\n      list = req.split(',');\n    }\n\n    if (val && !(val instanceof Array)) {\n      val = String(val); // if it is a number\n\n      for (i = 0; i < list.length; i++) {\n        if (val === list[i]) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    if (val && val instanceof Array) {\n      for (i = 0; i < val.length; i++) {\n        if (list.indexOf(val[i]) < 0) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  },\n\n  not_in: function(val, req) {\n    var list = req.split(',');\n    var len = list.length;\n    var returnVal = true;\n\n    val = String(val); // convert val to a string if it is a number\n\n    for (var i = 0; i < len; i++) {\n      if (val === list[i]) {\n        returnVal = false;\n        break;\n      }\n    }\n\n    return returnVal;\n  },\n\n  accepted: function(val) {\n    if (val === 'on' || val === 'yes' || val === 1 || val === '1' || val === true) {\n      return true;\n    }\n\n    return false;\n  },\n\n  confirmed: function(val, req, key) {\n    var confirmedKey = key + '_confirmation';\n\n    if (this.validator.input[confirmedKey] === val) {\n      return true;\n    }\n\n    return false;\n  },\n\n  integer: function(val) {\n    return String(parseInt(val, 10)) === String(val);\n  },\n\n  digits: function(val, req) {\n    var numericRule = this.validator.getRule('numeric');\n    if (numericRule.validate(val) && String(val).length === parseInt(req)) {\n      return true;\n    }\n\n    return false;\n  },\n\n  regex: function(val, req) {\n    var mod = /[g|i|m]{1,3}$/;\n    var flag = req.match(mod);\n    flag = flag ? flag[0] : \"\";\n    req = req.replace(mod, \"\").slice(1, -1);\n    req = new RegExp(req, flag);\n    return !!val.match(req);\n  },\n\n  date: function(val, format) {\n    return isValidDate(val);\n  },\n    \n  present: function(val) {\n    return typeof val !== 'undefined';\n  },\n\n  after: function(val, req){\n    var val1 = this.validator.input[req];\n    var val2 = val;\n\n    if(!isValidDate(val1)){ return false;}\n    if(!isValidDate(val2)){ return false;}\n\n    if (new Date(val1).getTime() < new Date(val2).getTime()) {\n      return true;\n    }\n\n    return false;\n  },\n\n   after_or_equal: function(val, req){\n    var val1 = this.validator.input[req];\n    var val2 = val;\n\n    if(!isValidDate(val1)){ return false;}\n    if(!isValidDate(val2)){ return false;}\n\n    if (new Date(val1).getTime() <= new Date(val2).getTime()) {\n      return true;\n    }\n\n    return false;\n  },\n\n  before: function(val, req){\n    var val1 = this.validator.input[req];\n    var val2 = val;\n\n    if(!isValidDate(val1)){ return false;}\n    if(!isValidDate(val2)){ return false;}\n\n    if (new Date(val1).getTime() > new Date(val2).getTime()) {\n      return true;\n    }\n\n    return false;\n  },\n\n   before_or_equal: function(val, req){\n    var val1 = this.validator.input[req];\n    var val2 = val;\n\n    if(!isValidDate(val1)){ return false;}\n    if(!isValidDate(val2)){ return false;}\n\n    if (new Date(val1).getTime() >= new Date(val2).getTime()) {\n      return true;\n    }\n\n    return false;\n  }\n\n\n};\n\nfunction Rule(name, fn, async) {\n  this.name = name;\n  this.fn = fn;\n  this.passes = null;\n  this.customMessage = undefined;\n  this.async = async;\n}\n\nRule.prototype = {\n\n  /**\n   * Validate rule\n   *\n   * @param  {mixed} inputValue\n   * @param  {mixed} ruleValue\n   * @param  {string} attribute\n   * @param  {function} callback\n   * @return {boolean|undefined}\n   */\n  validate: function(inputValue, ruleValue, attribute, callback) {\n    var _this = this;\n    this._setValidatingData(attribute, inputValue, ruleValue);\n    if (typeof callback === 'function') {\n      this.callback = callback;\n      var handleResponse = function(passes, message) {\n        _this.response(passes, message);\n      };\n\n      if (this.async) {\n        return this.fn.apply(this, [inputValue, ruleValue, attribute, handleResponse]);\n      } else {\n        return handleResponse(this.fn.apply(this, [inputValue, ruleValue, attribute]));\n      }\n    }\n    return this.fn.apply(this, [inputValue, ruleValue, attribute]);\n  },\n\n  /**\n   * Set validating data\n   *\n   * @param {string} attribute\n   * @param {mixed} inputValue\n   * @param {mixed} ruleValue\n   * @return {void}\n   */\n  _setValidatingData: function(attribute, inputValue, ruleValue) {\n    this.attribute = attribute;\n    this.inputValue = inputValue;\n    this.ruleValue = ruleValue;\n  },\n\n  /**\n   * Get parameters\n   *\n   * @return {array}\n   */\n  getParameters: function() {\n    return this.ruleValue ? this.ruleValue.split(',') : [];\n  },\n\n  /**\n   * Get true size of value\n   *\n   * @return {integer|float}\n   */\n  getSize: function() {\n    var value = this.inputValue;\n\n    if (value instanceof Array) {\n      return value.length;\n    }\n\n    if (typeof value === 'number') {\n      return value;\n    }\n\n    if (this.validator._hasNumericRule(this.attribute)) {\n      return parseFloat(value, 10);\n    }\n\n    return value.length;\n  },\n\n  /**\n   * Get the type of value being checked; numeric or string.\n   *\n   * @return {string}\n   */\n  _getValueType: function() {\n\n    if (typeof this.inputValue === 'number' || this.validator._hasNumericRule(this.attribute)) {\n      return 'numeric';\n    }\n\n    return 'string';\n  },\n\n  /**\n   * Set the async callback response\n   *\n   * @param  {boolean|undefined} passes  Whether validation passed\n   * @param  {string|undefined} message Custom error message\n   * @return {void}\n   */\n  response: function(passes, message) {\n    this.passes = (passes === undefined || passes === true);\n    this.customMessage = message;\n    this.callback(this.passes, message);\n  },\n\n  /**\n   * Set validator instance\n   *\n   * @param {Validator} validator\n   * @return {void}\n   */\n  setValidator: function(validator) {\n    this.validator = validator;\n  }\n\n};\n\nvar manager = {\n\n  /**\n   * List of async rule names\n   *\n   * @type {Array}\n   */\n  asyncRules: [],\n\n  /**\n   * Implicit rules (rules to always validate)\n   *\n   * @type {Array}\n   */\n  implicitRules: ['required', 'required_if', 'required_unless', 'required_with', 'required_with_all', 'required_without', 'required_without_all', 'accepted', 'present'],\n\n  /**\n   * Get rule by name\n   *\n   * @param  {string} name\n   * @param {Validator}\n   * @return {Rule}\n   */\n  make: function(name, validator) {\n    var async = this.isAsync(name);\n    var rule = new Rule(name, rules[name], async);\n    rule.setValidator(validator);\n    return rule;\n  },\n\n  /**\n   * Determine if given rule is async\n   *\n   * @param  {string}  name\n   * @return {boolean}\n   */\n  isAsync: function(name) {\n    for (var i = 0, len = this.asyncRules.length; i < len; i++) {\n      if (this.asyncRules[i] === name) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  /**\n   * Determine if rule is implicit (should always validate)\n   *\n   * @param {string} name\n   * @return {boolean}\n   */\n  isImplicit: function(name) {\n    return this.implicitRules.indexOf(name) > -1;\n  },\n\n  /**\n   * Register new rule\n   *\n   * @param  {string}   name\n   * @param  {function} fn\n   * @return {void}\n   */\n  register: function(name, fn) {\n    rules[name] = fn;\n  },\n\n  /**\n   * Register async rule\n   *\n   * @param  {string}   name\n   * @param  {function} fn\n   * @return {void}\n   */\n  registerAsync: function(name, fn) {\n    this.register(name, fn);\n    this.asyncRules.push(name);\n  }\n\n};\n\n\n\nmodule.exports = manager;\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/src/lang.js":"var Messages = require('./messages');\n\nrequire('./lang/en');\n\nvar container = {\n\n  messages: {},\n\n  /**\n   * Set messages for language\n   *\n   * @param {string} lang\n   * @param {object} rawMessages\n   * @return {void}\n   */\n  _set: function(lang, rawMessages) {\n    this.messages[lang] = rawMessages;\n  },\n\n  /**\n   * Set message for given language's rule.\n   *\n   * @param {string} lang\n   * @param {string} attribute\n   * @param {string|object} message\n   * @return {void}\n   */\n  _setRuleMessage: function(lang, attribute, message) {\n    this._load(lang);\n    if (message === undefined) {\n      message = this.messages[lang].def;\n    }\n\n    this.messages[lang][attribute] = message;\n  },\n\n  /**\n   * Load messages (if not already loaded)\n   *\n   * @param  {string} lang\n   * @return {void}\n   */\n  _load: function(lang) {\n    if (!this.messages[lang]) {\n      var rawMessages = require('./lang/' + lang);\n      this._set(lang, rawMessages);\n    }\n  },\n\n  /**\n   * Get raw messages for language\n   *\n   * @param  {string} lang\n   * @return {object}\n   */\n  _get: function(lang) {\n    this._load(lang);\n    return this.messages[lang];\n  },\n\n  /**\n   * Make messages for given language\n   *\n   * @param  {string} lang\n   * @return {Messages}\n   */\n  _make: function(lang) {\n    this._load(lang);\n    return new Messages(lang, this.messages[lang]);\n  }\n\n};\n\nmodule.exports = container;\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/src/messages.js":"var Attributes = require('./attributes');\n\nvar Messages = function(lang, messages) {\n  this.lang = lang;\n  this.messages = messages;\n  this.customMessages = {};\n  this.attributeNames = {};\n};\n\nMessages.prototype = {\n  constructor: Messages,\n\n  /**\n   * Set custom messages\n   *\n   * @param {object} customMessages\n   * @return {void}\n   */\n  _setCustom: function(customMessages) {\n    this.customMessages = customMessages || {};\n  },\n\n  /**\n   * Set custom attribute names.\n   *\n   * @param {object} attributes\n   */\n  _setAttributeNames: function(attributes) {\n    this.attributeNames = attributes;\n  },\n\n  /**\n   * Set the attribute formatter.\n   *\n   * @param {fuction} func\n   * @return {void}\n   */\n  _setAttributeFormatter: function(func) {\n    this.attributeFormatter = func;\n  },\n\n  /**\n   * Get attribute name to display.\n   *\n   * @param  {string} attribute\n   * @return {string}\n   */\n  _getAttributeName: function(attribute) {\n    var name = attribute;\n    if (this.attributeNames.hasOwnProperty(attribute)) {\n      return this.attributeNames[attribute];\n    } else if (this.messages.attributes.hasOwnProperty(attribute)) {\n      name = this.messages.attributes[attribute];\n    }\n\n    if (this.attributeFormatter) {\n      name = this.attributeFormatter(name);\n    }\n\n    return name;\n  },\n\n  /**\n   * Get all messages\n   *\n   * @return {object}\n   */\n  all: function() {\n    return this.messages;\n  },\n\n  /**\n   * Render message\n   *\n   * @param  {Rule} rule\n   * @return {string}\n   */\n  render: function(rule) {\n    if (rule.customMessage) {\n      return rule.customMessage;\n    }\n    var template = this._getTemplate(rule);\n\n    var message;\n    if (Attributes.replacements[rule.name]) {\n      message = Attributes.replacements[rule.name].apply(this, [template, rule]);\n    } else {\n      message = this._replacePlaceholders(rule, template, {});\n    }\n\n    return message;\n  },\n\n  /**\n   * Get the template to use for given rule\n   *\n   * @param  {Rule} rule\n   * @return {string}\n   */\n  _getTemplate: function(rule) {\n\n    var messages = this.messages;\n    var template = messages.def;\n    var customMessages = this.customMessages;\n    var formats = [rule.name + '.' + rule.attribute, rule.name];\n\n    for (var i = 0, format; i < formats.length; i++) {\n      format = formats[i];\n      if (customMessages.hasOwnProperty(format)) {\n        template = customMessages[format];\n        break;\n      } else if (messages.hasOwnProperty(format)) {\n        template = messages[format];\n        break;\n      }\n    }\n\n    if (typeof template === 'object') {\n      template = template[rule._getValueType()];\n    }\n\n    return template;\n  },\n\n  /**\n   * Replace placeholders in the template using the data object\n   *\n   * @param  {Rule} rule\n   * @param  {string} template\n   * @param  {object} data\n   * @return {string}\n   */\n  _replacePlaceholders: function(rule, template, data) {\n    var message, attribute;\n\n    data.attribute = this._getAttributeName(rule.attribute);\n    data[rule.name] = rule.getParameters().join(',');\n\n    if (typeof template === 'string' && typeof data === 'object') {\n      message = template;\n\n      for (attribute in data) {\n        message = message.replace(new RegExp(':' + attribute, 'g'), data[attribute]);\n      }\n    }\n\n    return message;\n  }\n\n};\n\nmodule.exports = Messages;\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/src/attributes.js":"var replacements = {\n\n  /**\n   * Between replacement (replaces :min and :max)\n   *\n   * @param  {string} template\n   * @param  {Rule} rule\n   * @return {string}\n   */\n  between: function(template, rule) {\n    var parameters = rule.getParameters();\n    return this._replacePlaceholders(rule, template, {\n      min: parameters[0],\n      max: parameters[1]\n    });\n  },\n\n  /**\n   * Required_if replacement.\n   *\n   * @param  {string} template\n   * @param  {Rule} rule\n   * @return {string}\n   */\n  required_if: function(template, rule) {\n    var parameters = rule.getParameters();\n    return this._replacePlaceholders(rule, template, {\n      other: parameters[0],\n      value: parameters[1]\n    });\n  },\n\n  /**\n   * Required_unless replacement.\n   *\n   * @param  {string} template\n   * @param  {Rule} rule\n   * @return {string}\n   */\n  required_unless: function(template, rule) {\n    var parameters = rule.getParameters();\n    return this._replacePlaceholders(rule, template, {\n      other: parameters[0],\n      value: parameters[1]\n    });\n  },\n\n  /**\n   * Required_with replacement.\n   *\n   * @param  {string} template\n   * @param  {Rule} rule\n   * @return {string}\n   */\n  required_with: function(template, rule) {\n    var parameters = rule.getParameters();\n    return this._replacePlaceholders(rule, template, {\n      field: parameters[0]\n    });\n  },\n\n  /**\n   * Required_with_all replacement.\n   *\n   * @param  {string} template\n   * @param  {Rule} rule\n   * @return {string}\n   */\n  required_with_all: function(template, rule) {\n    var parameters = rule.getParameters();\n    return this._replacePlaceholders(rule, template, {\n      fields: parameters.join(', ')\n    });\n  },\n\n  /**\n   * Required_without replacement.\n   *\n   * @param  {string} template\n   * @param  {Rule} rule\n   * @return {string}\n   */\n  required_without: function(template, rule) {\n    var parameters = rule.getParameters();\n    return this._replacePlaceholders(rule, template, {\n      field: parameters[0]\n    });\n  },\n\n  /**\n   * Required_without_all replacement.\n   *\n   * @param  {string} template\n   * @param  {Rule} rule\n   * @return {string}\n   */\n  required_without_all: function(template, rule) {\n    var parameters = rule.getParameters();\n    return this._replacePlaceholders(rule, template, {\n      fields: parameters.join(', ')\n    });\n  }\n};\n\nfunction formatter(attribute) {\n  return attribute.replace(/[_\\[]/g, ' ').replace(/]/g, '');\n}\n\nmodule.exports = {\n  replacements: replacements,\n  formatter: formatter\n};\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/src/lang/en.js":"module.exports = {\n  accepted: 'The :attribute must be accepted.',\n  after: 'The :attribute must be after :after.',\n  after_or_equal: 'The :attribute must be equal or after :after_or_equal.',\n  alpha: 'The :attribute field must contain only alphabetic characters.',\n  alpha_dash: 'The :attribute field may only contain alpha-numeric characters, as well as dashes and underscores.',\n  alpha_num: 'The :attribute field must be alphanumeric.',\n  before: 'The :attribute must be before :before.',\n  before_or_equal: 'The :attribute must be equal or before :before_or_equal.',\n  between: 'The :attribute field must be between :min and :max.',\n  confirmed: 'The :attribute confirmation does not match.',\n  email: 'The :attribute format is invalid.',\n  date: 'The :attribute is not a valid date format',\n  def: 'The :attribute attribute has errors.',\n  digits: 'The :attribute must be :digits digits.',\n  different: 'The :attribute and :different must be different.',\n  'in': 'The selected :attribute is invalid.',\n  integer: 'The :attribute must be an integer.',\n  min: {\n    numeric: 'The :attribute must be at least :min.',\n    string: 'The :attribute must be at least :min characters.'\n  },\n  max: {\n    numeric: 'The :attribute may not be greater than :max.',\n    string: 'The :attribute may not be greater than :max characters.'\n  },\n  not_in: 'The selected :attribute is invalid.',\n  numeric: 'The :attribute must be a number.',\n  present: 'The :attribute field must be present (but can be empty).',\n  required: 'The :attribute field is required.',\n  required_if: 'The :attribute field is required when :other is :value.',\n  required_unless: 'The :attribute field is required when :other is not :value.',\n  required_with: 'The :attribute field is required when :field is not empty.',\n  required_with_all: 'The :attribute field is required when :fields are not empty.',\n  required_without: 'The :attribute field is required when :field is empty.',\n  required_without_all: 'The :attribute field is required when :fields are empty.',\n  same: 'The :attribute and :same fields must match.',\n  size: {\n    numeric: 'The :attribute must be :size.',\n    string: 'The :attribute must be :size characters.'\n  },\n  string: 'The :attribute must be a string.',\n  url: 'The :attribute format is invalid.',\n  regex: 'The :attribute format is invalid',\n  attributes: {}\n};\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/src/errors.js":"var Errors = function() {\n  this.errors = {};\n};\n\nErrors.prototype = {\n  constructor: Errors,\n\n  /**\n   * Add new error message for given attribute\n   *\n   * @param  {string} attribute\n   * @param  {string} message\n   * @return {void}\n   */\n  add: function(attribute, message) {\n    if (!this.has(attribute)) {\n      this.errors[attribute] = [];\n    }\n\n    if (this.errors[attribute].indexOf(message) === -1) {\n      this.errors[attribute].push(message);\n    }\n  },\n\n  /**\n   * Returns an array of error messages for an attribute, or an empty array\n   *\n   * @param  {string} attribute A key in the data object being validated\n   * @return {array} An array of error messages\n   */\n  get: function(attribute) {\n    if (this.has(attribute)) {\n      return this.errors[attribute];\n    }\n\n    return [];\n  },\n\n  /**\n   * Returns the first error message for an attribute, false otherwise\n   *\n   * @param  {string} attribute A key in the data object being validated\n   * @return {string|false} First error message or false\n   */\n  first: function(attribute) {\n    if (this.has(attribute)) {\n      return this.errors[attribute][0];\n    }\n\n    return false;\n  },\n\n  /**\n   * Get all error messages from all failing attributes\n   *\n   * @return {Object} Failed attribute names for keys and an array of messages for values\n   */\n  all: function() {\n    return this.errors;\n  },\n\n  /**\n   * Determine if there are any error messages for an attribute\n   *\n   * @param  {string}  attribute A key in the data object being validated\n   * @return {boolean}\n   */\n  has: function(attribute) {\n    if (this.errors.hasOwnProperty(attribute)) {\n      return true;\n    }\n\n    return false;\n  }\n};\n\nmodule.exports = Errors;\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/src/async.js":"function AsyncResolvers(onFailedOne, onResolvedAll) {\n  this.onResolvedAll = onResolvedAll;\n  this.onFailedOne = onFailedOne;\n  this.resolvers = {};\n  this.resolversCount = 0;\n  this.passed = [];\n  this.failed = [];\n  this.firing = false;\n}\n\nAsyncResolvers.prototype = {\n\n  /**\n   * Add resolver\n   *\n   * @param {Rule} rule\n   * @return {integer}\n   */\n  add: function(rule) {\n    var index = this.resolversCount;\n    this.resolvers[index] = rule;\n    this.resolversCount++;\n    return index;\n  },\n\n  /**\n   * Resolve given index\n   *\n   * @param  {integer} index\n   * @return {void}\n   */\n  resolve: function(index) {\n    var rule = this.resolvers[index];\n    if (rule.passes === true) {\n      this.passed.push(rule);\n    } else if (rule.passes === false) {\n      this.failed.push(rule);\n      this.onFailedOne(rule);\n    }\n\n    this.fire();\n  },\n\n  /**\n   * Determine if all have been resolved\n   *\n   * @return {boolean}\n   */\n  isAllResolved: function() {\n    return (this.passed.length + this.failed.length) === this.resolversCount;\n  },\n\n  /**\n   * Attempt to fire final all resolved callback if completed\n   *\n   * @return {void}\n   */\n  fire: function() {\n\n    if (!this.firing) {\n      return;\n    }\n\n    if (this.isAllResolved()) {\n      this.onResolvedAll(this.failed.length === 0);\n    }\n\n  },\n\n  /**\n   * Enable firing\n   *\n   * @return {void}\n   */\n  enableFiring: function() {\n    this.firing = true;\n  }\n\n};\n\nmodule.exports = AsyncResolvers;\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/Gruntfile.js":"/*global module:false*/\nmodule.exports = function(grunt) {\n  'use strict';\n\n  require('jit-grunt')(grunt);\n\n  // Project configuration.\n  grunt.initConfig({\n    pkg: grunt.file.readJSON('package.json'),\n    jshint: {\n      all: 'src/*.js',\n      options: {\n        jshintrc: '.jshintrc'\n      }\n    },\n    browserify: {\n      ruLang: {\n        src: [],\n        options: {\n          require: ['./src/lang/ru:./lang/ru']\n        },\n        dest: 'dist/lang/ru.js'\n      },\n      deLang: {\n        src: [],\n        options: {\n          require: ['./src/lang/de:./lang/de']\n        },\n        dest: 'dist/lang/de.js'\n      },\n      elLang: {\n        src: [],\n        options: {\n          require: ['./src/lang/el:./lang/el']\n        },\n        dest: 'dist/lang/el.js'\n      },\n      esLang: {\n        src: [],\n        options: {\n          require: ['./src/lang/es:./lang/es']\n        },\n        dest: 'dist/lang/es.js'\n      },\n      frLang: {\n        src: [],\n        options: {\n          require: ['./src/lang/fr:./lang/fr']\n        },\n        dest: 'dist/lang/fr.js'\n      },\n      itLang: {\n        src: [],\n        options: {\n          require: ['./src/lang/it:./lang/it']\n        },\n        dest: 'dist/lang/it.js'\n      },\n      plLang: {\n        src: [],\n        options: {\n          require: ['./src/lang/pl:./lang/pl']\n        },\n        dest: 'dist/lang/pl.js'\n      },\n      faLang: {\n        src: [],\n        options: {\n          require: ['./src/lang/fa:./lang/fa']\n        },\n        dest: 'dist/lang/fa.js'\n      },\n      viLang: {\n        src: [],\n        options: {\n          require: ['./src/lang/vi:./lang/vi']\n        },\n        dest: 'dist/lang/vi.js'\n      },\n      ptLang: {\n        src: [],\n        options: {\n          require: ['./src/lang/pt:./lang/pt']\n        },\n        dest: 'dist/lang/pt.js'\n      },\n      jaLang: {\n        src: [],\n        options: {\n          require: ['./src/lang/ja:./lang/ja']\n        },\n        dest: 'dist/lang/ja.js'\n      },\n      trLang: {\n        src: [],\n        options: {\n          require: ['./src/lang/tr:./lang/tr']\n        },\n        dest: 'dist/lang/tr.js'\n      },\n      zhLang: {\n        src: [],\n        options: {\n          require: ['./src/lang/zh:./lang/zh']\n        },\n        dest: 'dist/lang/zh.js'\n      },\n      zhTWLang: {\n        src: [],\n        options: {\n          require: ['./src/lang/zh_TW:./lang/zh_TW']\n        },\n        dest: 'dist/lang/zh_TW.js'\n      },\n      nbNOLang: {\n          src: [],\n          options: {\n              require: ['./src/lang/nb_NO:./lang/nb_NO']\n          },\n          dest: 'dist/lang/nb_NO.js'\n      },\n      dist: {\n        files: {\n          'dist/validator.js': 'src/validator.js'\n        },\n        options: {\n          banner: \"/*! <%= pkg.name %> - v<%= pkg.version %> - <%= pkg.homepage %> - \" +\n          \"<%= grunt.template.today('yyyy-mm-dd') %> */\",\n          browserifyOptions: {\n            standalone: 'Validator'\n          }\n        }\n      }\n    },\n    uglify: {\n      options: {\n        banner: '/*! <%= pkg.name %> - v<%= pkg.version %> - <%= pkg.homepage %> - <%= grunt.template.today(\"yyyy-mm-dd\") %> */'\n      },\n      dist: {\n        src: 'dist/validator.js',\n        dest: 'dist/validator.min.js'\n      }\n    },\n    watch: {\n      files: ['src/**/*.js'],\n      tasks: ['default']\n    }\n  });\n\n  // Default task.\n  grunt.registerTask('build', ['browserify']);\n  grunt.registerTask('dist', ['jshint', 'build', 'uglify']);\n  grunt.registerTask('default', ['dist']);\n\n};\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/karma.conf.js":"// Karma configuration\n// Generated on Sat Jul 12 2014 14:48:42 GMT-0700 (PDT)\n\nmodule.exports = function(config) {\n  config.set({\n\n    // base path that will be used to resolve all patterns (eg. files, exclude)\n    basePath: '',\n\n\n    // frameworks to use\n    // available frameworks: https://npmjs.org/browse/keyword/karma-adapter\n    frameworks: ['mocha', 'chai'],\n\n\n    // list of files / patterns to load in the browser\n    files: [\n      'dist/validator.js',\n      'spec/*.js'\n    ],\n\n\n    // list of files to exclude\n    exclude: [\n\n    ],\n\n\n    // preprocess matching files before serving them to the browser\n    // available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor\n    preprocessors: {\n        'dist/validator.js': ['coverage']\n    },\n\n    // test results reporter to use\n    // possible values: 'dots', 'progress'\n    // available reporters: https://npmjs.org/browse/keyword/karma-reporter\n    reporters: ['progress', 'coverage', 'growl-notifications'],\n\n\n    // web server port\n    port: 9876,\n\n\n    // enable / disable colors in the output (reporters and logs)\n    colors: true,\n\n\n    // level of logging\n    // possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG\n    logLevel: config.LOG_INFO,\n\n\n    // enable / disable watching file and executing tests whenever any file changes\n    autoWatch: true,\n\n\n    // start these browsers\n    // available browser launchers: https://npmjs.org/browse/keyword/karma-launcher\n    browsers: ['PhantomJS'],\n\n\n    // Continuous Integration mode\n    // if true, Karma captures browsers, runs the tests and exits\n    singleRun: false\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/accepted-rule.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('accepted validation rule', function() {\n  it('should pass if the value is yes', function() {\n    var validator = new Validator({\n      terms: 'yes'\n    }, {\n      terms: 'accepted'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n  it('should pass if the value is on', function() {\n    var validator = new Validator({\n      terms: 'on'\n    }, {\n      terms: 'accepted'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false\n  });\n\n  it('should pass if the value is the number 1', function() {\n    var validator = new Validator({\n      terms: 1\n    }, {\n      terms: 'accepted'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n  it('should pass if the value is the string 1', function() {\n    var validator = new Validator({\n      terms: '1'\n    }, {\n      terms: 'accepted'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n  it('should pass if the value is a boolean true', function() {\n    var validator = new Validator({\n      terms: true\n    }, {\n      terms: 'accepted'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n  it('should fail if the value is not 1, on, or yes', function() {\n    var validator = new Validator({\n      terms: '10'\n    }, {\n      terms: 'accepted'\n    });\n    expect(validator.passes()).to.be.false;\n    expect(validator.fails()).to.be.true;\n  });\n\n  it('should fail if the value is an empty string', function() {\n    var validator = new Validator({\n      terms: ''\n    }, {\n      terms: 'accepted'\n    });\n    expect(validator.passes()).to.be.false;\n    expect(validator.fails()).to.be.true;\n  });\n\n  it('should fail if the value is undefined', function() {\n    var validator = new Validator({}, {\n      terms: 'accepted'\n    });\n    expect(validator.passes()).to.be.false;\n    expect(validator.fails()).to.be.true;\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/after_or_equal-rule.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('after or equal rule', function() {\n  it('should fail when the comparing attribute are greather', function() {\n    var validator = new Validator({\n      date: '1996-12-09',\n      date2: '1995-08-09',\n    },{\n      date2: 'after_or_equal:date'\n    });\n\n    expect(validator.fails()).to.be.true;\n    expect(validator.passes()).to.be.false;\n    expect(validator.errors.first('date2')).to.equal('The date2 must be equal or after date.');\n  });\n\n  it('should pass when the comparing attribute are equal', function() {\n    var validator = new Validator({\n      date: '1995-08-09',\n      date2: '1995-08-09',\n    },{\n      date2: 'after_or_equal:date'\n    });\n\n    expect(validator.fails()).to.be.false;\n    expect(validator.passes()).to.be.true;\n  \n  });\n\n  it('should pass when the comparing attribute are smaller', function() {\n    var validator = new Validator({\n      date: '1995-08-09',\n      date2: '1996-12-09',\n    },{\n      date2: 'after_or_equal:date'\n    });\n\n    expect(validator.fails()).to.be.false;\n    expect(validator.passes()).to.be.true;\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/after-rule.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('after rule', function() {\n  it('should fail when the comparing attribute are greather', function() {\n    var validator = new Validator({\n      date: '1996-12-09',\n      date2: '1995-08-09',\n    },{\n      date2: 'after:date'\n    });\n\n    expect(validator.fails()).to.be.true;\n    expect(validator.passes()).to.be.false;\n    expect(validator.errors.first('date2')).to.equal('The date2 must be after date.');\n  });\n\n  it('should fail when the comparing attribute are equal', function() {\n    var validator = new Validator({\n      date: '1995-08-09',\n      date2: '1995-08-09',\n    },{\n      date2: 'after:date'\n    });\n\n    expect(validator.fails()).to.be.true;\n    expect(validator.passes()).to.be.false;\n    expect(validator.errors.first('date2')).to.equal('The date2 must be after date.');\n  });\n\n  it('should pass when the comparing attribute are smaller', function() {\n    var validator = new Validator({\n      date: '1995-08-09',\n      date2: '1996-12-09',\n    },{\n      date2: 'after:date'\n    });\n\n    expect(validator.fails()).to.be.false;\n    expect(validator.passes()).to.be.true;\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/alpha_dash-rule.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('alpha_dash validation rule', function() {\n  it('should fail with non alpha dash characters', function() {\n    var validator = new Validator({\n      name: 'David *'\n    }, {\n      name: 'alpha_dash'\n    });\n    expect(validator.passes()).to.be.false;\n    expect(validator.fails()).to.be.true;\n  });\n\n  it('should fail with non-alphabetic characters', function() {\n    var validator = new Validator({\n      name: 12\n    }, {\n      name: 'alpha_dash'\n    });\n    expect(validator.fails()).to.be.false;\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should pass with only alpha dash characters', function() {\n    var validator = new Validator({\n      name: 'David9_-'\n    }, {\n      name: 'alpha_dash'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n  it('should pass when the field is blank / optional', function() {\n    var validator = new Validator({\n      name: ''\n    }, {\n      name: 'alpha_dash'\n    });\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should pass when the field does not exist', function() {\n    var validator = new Validator({}, {\n      name: 'alpha_dash'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/alpha_num-rule.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('alpha_num validation rule', function() {\n  it('should fail with non-alphanumeric characters', function() {\n    var validator = new Validator({\n      age: '$'\n    }, {\n      age: 'alpha_num'\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.passes()).to.be.false;\n    expect(validator.errors.first('age')).to.equal('The age field must be alphanumeric.');\n  });\n\n  it('should pass with only alphanumeric characters', function() {\n    var validator = new Validator({\n      age: 'abc123'\n    }, {\n      age: 'alpha_num'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n  it('should pass with only numeric characters', function() {\n    var validator = new Validator({\n      age: 123\n    }, {\n      age: 'alpha_num'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n  it('should pass when the field is blank / optional', function() {\n    var validator = new Validator({\n      name: ''\n    }, {\n      name: 'alpha_num'\n    });\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should pass when the field does not exist', function() {\n    var validator = new Validator({}, {\n      name: 'alpha_num'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/alpha-rule.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('alpha validation rule', function() {\n  it('should fail with non-alphabetic characters', function() {\n    var validator = new Validator({\n      name: '12'\n    }, {\n      name: 'alpha'\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.passes()).to.be.false;\n  });\n\n  it('should fail with non-alphabetic characters', function() {\n    var validator = new Validator({\n      name: 12\n    }, {\n      name: 'alpha'\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.passes()).to.be.false;\n  });\n\n  it('should pass with only alphabetic characters', function() {\n    var validator = new Validator({\n      name: 'abc'\n    }, {\n      name: 'alpha'\n    });\n    expect(validator.fails()).to.be.false;\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should pass when the field is an empty string', function() {\n    var validator = new Validator({\n      name: ''\n    }, {\n      name: 'alpha'\n    });\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should pass when the field does not exist', function() {\n    var validator = new Validator({}, {\n      name: 'alpha'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/alternative-initialization.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('alternative initialization using an array instead pipe', function() {\n  beforeEach(function() {\n    validator = new Validator({\n      name: 'David',\n      email: 'johndoe@gmail.com',\n      salary: '10,000.00',\n      birthday: '03/07/1980',\n      nick: 'Dav'\n    }, {\n      name: ['required', 'min:3', 'max:10'],\n      email: ['required', 'email'],\n      salary: ['required', 'regex:/^\\\\$?(?!0.00)(([0-9]{1,3},([0-9]{3},)*)[0-9]{3}|[0-9]{1,3})(\\\\.[0-9]{2})?$/'],\n      birthday: ['required', 'regex:/^([1-9]|0[1-9]|[12][0-9]|3[01])\\\\D([1-9]|0[1-9]|1[012])\\\\D(19[0-9][0-9]|20[0-9][0-9])$/'],\n      nick: ['required', 'regex:/^X/']\n    });\n  });\n\n  it('should fail 1 validation rule', function() {\n    expect(validator.passes()).to.be.false;\n    expect(validator.fails()).to.be.true;\n    expect(validator.errors.first('nick')).to.equal('The nick format is invalid');\n  });\n}); // Page constructor\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/array.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('array rule', function() {\n  it('should pass when array', function() {\n    var validator = new Validator({\n      users: []\n    }, {\n      users: 'array'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n  it('should fail when given object', function() {\n    var validator = new Validator({\n      users: {}\n    }, {\n      users: 'array'\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.passes()).to.be.false;\n  });\n\n  it('should fail when given boolean', function() {\n    var validator = new Validator({\n      users: true\n    }, {\n      users: 'array'\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.passes()).to.be.false;\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/async-rule.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('async rule tests', function() {\n  this.timeout(200);\n\n  it('should be able to register and pass async rule', function(done) {\n    Validator.registerAsync('username', function(desiredUsername, ruleValue, attribute, passes) {\n      setTimeout(function() {\n        if (desiredUsername == 'test') {\n          passes();\n        }\n      }, 50);\n    }, ':attribute is an invalid username');\n\n    var validator = new Validator({\n      username: 'test'\n    }, {\n      username: 'username'\n    });\n    validator.passes(done);\n  });\n\n  it('should be able to fail async rules', function(done) {\n    Validator.registerAsync('username', function(desiredUsername, ruleValue, attribute, passes) {\n      setTimeout(function() {\n        if (desiredUsername == 'test') {\n          passes(false);\n        }\n      }, 50);\n    }, ':attribute is an invalid username');\n\n    var validator = new Validator({\n      username: 'test'\n    }, {\n      username: 'username'\n    });\n    validator.fails(done);\n  });\n\n  it('should pass on multiple async rules', function(done) {\n    var passCount = 0;\n\n    Validator.registerAsync('username1', function(desiredUsername, ruleValue, attribute, passes) {\n      setTimeout(function() {\n        if (desiredUsername == 'test') {\n          passCount++;\n          passes();\n        }\n      }, 50);\n    }, ':attribute is an invalid username');\n\n    Validator.registerAsync('username2', function(desiredUsername, ruleValue, attribute, passes) {\n      setTimeout(function() {\n        if (desiredUsername == 'test') {\n          passCount++;\n          passes();\n        }\n      }, 50);\n    }, ':attribute is an invalid username');\n\n    var validator = new Validator({\n      username: 'test'\n    }, {\n      username: 'username1|username2'\n    });\n    validator.passes(function() {\n      expect(passCount).to.equal(2);\n      done();\n    });\n  });\n\n  it('should fail on mixture of pass/fail async rules', function(done) {\n    var failedCount = 0;\n    var passCount = 0;\n\n    Validator.registerAsync('username1', function(desiredUsername, ruleValue, attribute, passes) {\n      setTimeout(function() {\n        if (desiredUsername == 'test') {\n          passCount++;\n          passes();\n        }\n      }, 50);\n    }, ':attribute is an invalid username');\n\n    Validator.registerAsync('username2', function(desiredUsername, ruleValue, attribute, passes) {\n      setTimeout(function() {\n        if (desiredUsername == 'test') {\n          failedCount++;\n          passes(false);\n        }\n      }, 50);\n    }, ':attribute is an invalid username');\n\n    var validator = new Validator({\n      username: 'test'\n    }, {\n      username: 'username1|username2'\n    });\n    validator.fails(function() {\n      expect(passCount).to.equal(1);\n      expect(failedCount).to.equal(1);\n      done();\n    });\n  });\n\n  it('should allow custom error message', function(done) {\n    Validator.registerAsync('username', function(desiredUsername, ruleValue, attribute, passes) {\n      setTimeout(function() {\n        if (desiredUsername == 'admin') {\n          passes(false, 'This username is banned');\n        }\n      }, 50);\n    }, ':attribute is an invalid username');\n\n    var validator = new Validator({\n      username: 'admin'\n    }, {\n      username: 'username'\n    });\n    validator.fails(function() {\n      expect(validator.errors.first('username')).to.equal('This username is banned');\n      done();\n    });\n  });\n\n  it('should allow validating by async when no async rules', function(done) {\n    var validator = new Validator({\n      username: 'admin',\n      email: 'blah'\n    }, {\n      username: 'required|min:3',\n      email: 'required|email'\n    });\n    validator.fails(function() {\n      done();\n    });\n\n    validator.passes(function() {\n      throw 'Should not have passed.';\n    });\n  });\n\n  it('should it pass on mixture of sync/async rules', function(done) {\n    Validator.registerAsync('username', function(desiredUsername, ruleValue, attribute, passes) {\n      setTimeout(function() {\n        if (desiredUsername == 'test') {\n          passes();\n        }\n      }, 50);\n    }, ':attribute is an invalid username');\n\n    var validator = new Validator({\n      username: 'test'\n    }, {\n      username: 'required|min:3|username'\n    });\n    validator.passes(done);\n  });\n\n  it('should it not call passes if using just fails callback', function(done) {\n    var validator = new Validator({\n      name: 'gary'\n    }, {\n      name: 'required'\n    });\n    validator.fails(function() {\n      throw 'Should not be called.'\n    });\n\n    validator.passes(function() {\n      done();\n    });\n  });\n\n\n  it('should it not call fails if using just passes callback', function(done) {\n    var validator = new Validator({\n      name: ''\n    }, {\n      name: 'required'\n    });\n    validator.passes(function() {\n      throw 'Should not be called.'\n    });\n\n    validator.fails(function() {\n      done();\n    });\n  });\n\n  // it('should throw exception when attempting to validate and no fail or pass callback', function() {\n\n  // \tValidator.registerAsync('username', function() { });\n  // \tvar validator = new Validator({ username: 'admin' }, { username: 'username' });\n  // \texpect(validator.passes).to.throw(/^passes expects.*/);\n\n  // });\n\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/attribute-formatter.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('attribute formatter tests', function() {\n  it('should replace _[] with spaces by default', function() {\n    var validator = new Validator({\n      'all_users[3][first_name]': ''\n    }, {\n      'all_users[3][first_name]': 'required'\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.errors.first('all_users[3][first_name]')).to.equal('The all users 3 first name field is required.');\n  });\n\n  it('should be able configure global attribute formatter', function() {\n    var originalAttributeFormatter = Validator.prototype.attributeFormatter;\n    Validator.setAttributeFormatter(function(attribute) {\n      return attribute.replace(/_/, ' ');\n    });\n    var validator = new Validator({\n      first_name: ''\n    }, {\n      first_name: 'required'\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.errors.first('first_name')).to.equal('The first name field is required.');\n    Validator.setAttributeFormatter(originalAttributeFormatter);\n  });\n\n  it('should be able configure attribute formatter for particular instance', function() {\n    var validator = new Validator({\n      first_name: ''\n    }, {\n      first_name: 'required'\n    });\n    validator.setAttributeFormatter(function(attribute) {\n      return attribute;\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.errors.first('first_name')).to.equal('The first_name field is required.');\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/attribute-names.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('custom attribute names', function() {\n  it('should allow custom attribute names', function() {\n    var validator = new Validator({\n      name: ''\n    }, {\n      name: 'required'\n    });\n    validator.setAttributeNames({\n      name: 'custom_name'\n    })\n    expect(validator.fails()).to.be.true;\n    expect(validator.errors.first('name')).to.equal('The custom_name field is required.');\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/before_or_equal-rule.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('before or equal rule', function() {\n  it('should fail when the comparing attribute are smaller', function() {\n    var validator = new Validator({\n      date: '1994-12-09',\n      date2: '1998-08-09',\n    },{\n      date2: 'before_or_equal:date'\n    });\n\n    expect(validator.fails()).to.be.true;\n    expect(validator.passes()).to.be.false;\n    expect(validator.errors.first('date2')).to.equal('The date2 must be equal or before date.');\n  });\n\n  it('should pass when the comparing attribute are equal', function() {\n    var validator = new Validator({\n      date: '1994-12-09',\n      date2: '1994-12-09',\n    },{\n      date2: 'before_or_equal:date'\n    });\n\n    expect(validator.fails()).to.be.false;\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should pass when the comparing attribute are greather', function() {\n    var validator = new Validator({\n      date: '1998-08-09',\n      date2: '1994-12-09',\n    },{\n      date2: 'before_or_equal:date'\n    });\n\n    expect(validator.fails()).to.be.false;\n    expect(validator.passes()).to.be.true;\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/before-rule.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('before rule', function() {\n  it('should fail when the comparing attribute are smaller', function() {\n    var validator = new Validator({\n      date: '1994-12-09',\n      date2: '1998-08-09',\n    },{\n      date2: 'before:date'\n    });\n\n    expect(validator.fails()).to.be.true;\n    expect(validator.passes()).to.be.false;\n    expect(validator.errors.first('date2')).to.equal('The date2 must be before date.');\n  });\n\n  it('should fail when the comparing attribute are equal', function() {\n    var validator = new Validator({\n      date: '1994-12-09',\n      date2: '1994-12-09',\n    },{\n      date2: 'before:date'\n    });\n\n    expect(validator.fails()).to.be.true;\n    expect(validator.passes()).to.be.false;\n    expect(validator.errors.first('date2')).to.equal('The date2 must be before date.');\n  });\n\n  it('should pass when the comparing attribute are greather', function() {\n    var validator = new Validator({\n      date: '1998-08-09',\n      date2: '1994-12-09',\n    },{\n      date2: 'before:date'\n    });\n\n    expect(validator.fails()).to.be.false;\n    expect(validator.passes()).to.be.true;\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/between-rule.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('between rule', function() {\n  it('should pass between rule when 25 and between 18 - 30', function() {\n    var validator = new Validator({\n      num: 25\n    }, {\n      num: 'between:18,30'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n  it('should pass between rule when 25 and between 25 - 30', function() {\n    var validator = new Validator({\n      num: 25\n    }, {\n      num: 'between:25,30'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n  it('should fail on string 25 when between is set to 25 - 30', function() {\n    var validator = new Validator({\n      num: '25'\n    }, {\n      num: 'between:25,30'\n    });\n    expect(validator.passes()).to.be.false;\n    expect(validator.fails()).to.be.true;\n  });\n\n  it('should pass on string 25 when between is set to 2 - 3', function() {\n    var validator = new Validator({\n      num: '25'\n    }, {\n      num: 'between:2,3'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n  it('should threat string 25 as numeric when other numeric rules are set and pass when between is set to 25 - 30', function() {\n    var validator = new Validator({\n      num: '25'\n    }, {\n      num: 'between:25,30|numeric'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n  it('should support floats', function() {\n    var validator = new Validator({\n      num1: 25.12,\n      num2: 0.03\n    }, {\n      num1: 'between:25.11,25.13',\n      num2: 'between:0.02,0.04'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n  it('should support unsigned', function() {\n    var validator = new Validator({\n      num: -3\n    }, {\n      num: 'between:-4,-2'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n  it('should support array', function() {\n    var validator = new Validator({\n      array2: ['a', 'b']\n    }, {\n      array2: 'required|between:1,2'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n  it('should generate proper error message', function() {\n    var validator = new Validator({\n      num: '14'\n    }, {\n      num: 'between:16,23'\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.errors.first('num')).to.equal('The num field must be between 16 and 23.');\n  });\n\n  it('should fail when passed invalid values', function() {\n    var validator = new Validator({\n      numNull: null,\n      numUndefined: undefined,\n      numEmpty: '',\n      numOutOfBounds: 24,\n      numOutOfBoundsUnsigned: -34\n    }, {\n      numNull: 'between:25,30',\n      numUndefined: 'between:25,30',\n      numEmpty: 'between:25,30',\n      numOutOfBounds: 'between:25,30',\n      numOutOfBoundsUnsigned: 'between:-35,150',\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.passes()).to.be.false;\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/boolean-rule.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('boolean validation rule', function() {\n  it('should pass with a boolean value', function() {\n    var validator = new Validator({\n      isHappy: true\n    }, {\n      isHappy: 'boolean'\n    });\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should pass with a decimal boolean value', function() {\n    var validator = new Validator({\n      isHappy: 1,\n      isSad: 0\n    }, {\n      isHappy: 'boolean',\n      isSad: 'boolean'\n    });\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should pass with a string boolean value', function() {\n    var validator = new Validator({\n      firstOne: 'true',\n      secondOne: 'false',\n      thirdOne: '0',\n      fourthOne: '1',\n    }, {\n      firstOne: 'boolean',\n      secondOne: 'boolean',\n      thirdOne: 'boolean',\n      fourthOne: 'boolean'\n    });\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should fail with an incorrect string value', function() {\n    var validator = new Validator({\n      firstOne: 'truee',\n    }, {\n      firstOne: 'boolean',\n    });\n    expect(validator.fails()).to.be.true;\n  });\n\n  it('should pass with no value', function() {\n    var validator = new Validator({}, {\n      age: 'boolean'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n  it('should pass with an empty string value', function() {\n    var validator = new Validator({\n      age: ''\n    }, {\n      age: 'boolean'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/confirmed-rule.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('confirmed validation rule', function() {\n  it('should fail without a matching confirmation field for the field under validation', function() {\n    var validator = new Validator({\n      password: 'abc'\n    }, {\n      password: 'confirmed'\n    });\n    expect(validator.passes()).to.be.false;\n    expect(validator.fails()).to.be.true;\n  });\n\n  it('should fail without a matching confirmation field for the field under validation', function() {\n    var validator = new Validator({\n      password: 'abc',\n      password_confirmation: 'abcd'\n    }, {\n      password: 'confirmed'\n    });\n    expect(validator.passes()).to.be.false;\n    expect(validator.fails()).to.be.true;\n    expect(validator.errors.first('password')).to.equal('The password confirmation does not match.');\n  });\n\n  it('should pass with a matching confirmation field for the field under validation', function() {\n    var validator = new Validator({\n      password: 'abc',\n      password_confirmation: 'abc'\n    }, {\n      password: 'confirmed'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/custom-messages.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('Validator custom messages', function() {\n  it('override the default message for the validator', function() {\n    var validator = new Validator({\n      name: ''\n    }, {\n      name: 'required'\n    }, {\n      required: 'Name is missing.'\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.errors.get('name').length).to.equal(1);\n    expect(validator.errors.first('name')).to.equal('Name is missing.');\n  });\n\n  it('override the default message for a type of the validator', function() {\n    var validator = new Validator({\n      name: 'A'\n    }, {\n      name: 'min:4'\n    }, {\n      min: {\n        string: ':attribute is not long enough. Should be :min.'\n      }\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.errors.get('name').length).to.equal(1);\n    expect(validator.errors.first('name')).to.equal('name is not long enough. Should be 4.');\n  });\n\n  it('override the default message for the validator with several :attribute in message', function() {\n    var validator = new Validator({\n      name: ''\n    }, {\n      name: 'required'\n    }, {\n      required: ':attribute is required. :attribute can\\'t be empty.'\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.errors.get('name').length).to.equal(1);\n    expect(validator.errors.first('name')).to.equal('name is required. name can\\'t be empty.');\n  });\n\n  it('override the default message for a type of the validator', function() {\n    var validator = new Validator({\n      name: 'A'\n    }, {\n      name: 'min:4'\n    }, {\n      min: {\n        string: ':attribute is not long enough. Should be :min.'\n      }\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.errors.get('name').length).to.equal(1);\n    expect(validator.errors.first('name')).to.equal('name is not long enough. Should be 4.');\n  });\n\n  it('override the default message for a type of the validator with several :attribute and :min in message', function() {\n    var validator = new Validator({\n      name: 'A'\n    }, {\n      name: 'min:4'\n    }, {\n      min: {\n        string: ':attribute is not long enough. :attribute should be :min. Because needed string with :min symbols or more.'\n      }\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.errors.get('name').length).to.equal(1);\n    expect(validator.errors.first('name')).to.equal('name is not long enough. name should be 4. Because needed string with 4 symbols or more.');\n  });\n\n  it('can be specified on a per attribute basis for a validator', function() {\n    var validator = new Validator({\n      name: '',\n      email: ''\n    }, {\n      name: 'required',\n      email: 'required'\n    }, {\n      'required.name': 'Name is missing.'\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.errors.get('name').length).to.equal(1);\n    expect(validator.errors.first('name')).to.equal('Name is missing.');\n    expect(validator.errors.get('email').length).to.equal(1);\n    expect(validator.errors.first('email')).to.equal('The email field is required.');\n  });\n\n  it('can be specified for custom validators', function() {\n    Validator.register('telephone', function(value, requirement, attribute) {\n      return value.match(/^\\d{3}-\\d{3}-\\d{4}$/);\n    }, 'The :attribute phone number is not in the format XXX-XXX-XXXX.');\n\n    var validator = new Validator({\n      phone: '1234567890'\n    }, {\n      phone: 'telephone'\n    }, {\n      telephone: 'Wrong number.'\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.errors.get('phone').length).to.equal(1);\n    expect(validator.errors.first('phone')).to.equal('Wrong number.');\n  });\n\n  it('can be specified for custom validators per attribute', function() {\n    Validator.register('telephone', function(value, requirement, attribute) {\n      return value.match(/^\\d{3}-\\d{3}-\\d{4}$/);\n    }, 'The :attribute phone number is not in the format XXX-XXX-XXXX.');\n\n    var validator = new Validator({\n      phone: '1234567890',\n      fax: '1234567890'\n    }, {\n      phone: 'telephone',\n      fax: 'telephone'\n    }, {\n      'telephone.fax': 'Why are you even using a fax?'\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.errors.get('phone').length).to.equal(1);\n    expect(validator.errors.first('phone')).to.equal('The phone phone number is not in the format XXX-XXX-XXXX.');\n    expect(validator.errors.get('fax').length).to.equal(1);\n    expect(validator.errors.first('fax')).to.equal('Why are you even using a fax?');\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/date-rule.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('date rule', function() {\n  it('should pass for correct, parsable date format', function() {\n    var asserts = [\n      807926400000,\n      'Aug 9, 1995',\n      'Wed, 09 Aug 1995 00:00:00 GMT',\n      'Wed, 09 Aug 1995 00:00:00',\n      '1995-08-09',\n      '1995-08-09T00:00:00+00:00',\n      '1995-08-09T00:00:00Z',\n      '1995-08-09T00:00:00.000Z',\n      (new Date())\n    ];\n\n    asserts.forEach(function (assert) {\n      var validator = new Validator({\n        date: assert\n      }, {\n        date: 'date'\n      });\n      expect(validator.passes()).to.be.true;\n      expect(validator.fails()).to.be.false;\n    });\n  });\n\n  it('should pass for correct date formats', function() {\n    var validator;\n\n    validator = new Validator({passingDate: 'Friday, March 17 2017'}, {passingDate: 'date'});\n    expect(validator.passes()).to.be.true;\n\n    validator = new Validator({passingDate: '2017-03-18'}, {passingDate: 'date'});\n    expect(validator.passes()).to.be.true;\n\n    validator = new Validator({passingDate: '2017-03-18'}, {passingDate: 'date'});\n    expect(validator.passes()).to.be.true;\n\n    validator = new Validator({passingDate: '2017.03.18'}, {passingDate: 'date'});\n    expect(validator.passes()).to.be.true;\n\n  });\n\n  it('should fail for incorrect date formats', function() {\n\n    var validator;\n\n    validator = new Validator({failDate: '2014-25-23'}, {failDate: 'date'});\n    expect(validator.fails()).to.be.true;\n\n    validator = new Validator({failDate: 'foo-bar'}, {failDate: 'date'});\n    expect(validator.fails()).to.be.true;\n\n    validator = new Validator({failDate: '0908 1995'}, {failDate: 'date'});\n    expect(validator.fails()).to.be.true;\n\n    validator = new Validator({failDate: '9/39/19'}, {failDate: 'date'});\n    expect(validator.fails()).to.be.true;\n\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/different-rule.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('different validation rule', function() {\n  it('should fail when the 2 attributes are the same', function() {\n    var validator = new Validator({\n      field1: 'abc',\n      field2: 'abc'\n    }, {\n      field2: 'different:field1'\n    });\n    expect(validator.passes()).to.be.false;\n    expect(validator.fails()).to.be.true;\n  });\n\n  it('should pass when the 2 attributes are different', function() {\n    var validator = new Validator({\n      field1: 'abc',\n      field2: 'abcd'\n    }, {\n      field2: 'different:field1'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/digits-rule.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('digits rule', function() {\n  it('should be numeric and must have an exact length of 5', function() {\n    var validation = new Validator({\n      zip: '90989'\n    }, {\n      zip: 'digits:5'\n    });\n\n    expect(validation.passes()).to.be.true;\n    expect(validation.fails()).to.be.false;\n  });\n\n  it('should not pass if non-digits are present', function() {\n    var validation = new Validator({\n      zip: '9098a'\n    }, {\n      zip: 'digits:5'\n    });\n\n    expect(validation.fails()).to.be.true;\n    expect(validation.errors.first('zip')).to.equal('The zip must be 5 digits.');\n    expect(validation.passes()).to.be.false;\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/email-rule.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('email validation rule', function() {\n  it('should pass with the email address: johndoe@gmail.com', function() {\n    var validator = new Validator({\n      email: 'johndoe@gmail.com'\n    }, {\n      email: 'email'\n    });\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should fail with the email address: johndoe.gmail.com', function() {\n    var validator = new Validator({\n      email: 'johndoe.gmail.com'\n    }, {\n      email: 'email'\n    });\n    expect(validator.fails()).to.be.true;\n  });\n\n  it('should fail with the email address: johndoe@gmail', function() {\n    var validator = new Validator({\n      email: 'johndoe@gmail'\n    }, {\n      email: 'email'\n    });\n    expect(validator.fails()).to.be.true;\n  });\n\n  it('should fail when the email address contains whitespace only and is required', function() {\n    var validator = new Validator({\n      email: '   '\n    }, {\n      email: 'required|email'\n    });\n    expect(validator.fails()).to.be.true;\n  });\n\n  it('should pass when the field is an empty string', function() {\n    var validator = new Validator({\n      email: ''\n    }, {\n      email: 'email'\n    });\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should pass when the field does not exist', function() {\n    var validator = new Validator({}, {\n      email: 'email'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n  it('should pass with first.last@example.com', function() {\n    var validator = new Validator({\n      email: 'first.last@example.com'\n    }, {\n      email: 'email'\n    });\n\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/error-count.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('Error counts', function() {\n  it('should return 0 when validation has not yet run', function() {\n    var validator = new Validator({\n      username: ''\n    }, {\n      username: 'required'\n    });\n    expect(validator.errorCount).to.equal(0);\n  });\n\n  it('should return a count when there are errors', function() {\n    var validator = new Validator({\n      username: '',\n      name: ''\n    }, {\n      username: 'required',\n      name: 'required'\n    });\n    expect(validator.passes()).to.be.false;\n    expect(validator.errorCount).to.equal(2);\n  });\n\n  it('should not return a count when error free', function() {\n    var validator = new Validator({\n      username: 'a',\n      name: 'a'\n    }, {\n      username: 'required',\n      name: 'required'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.errorCount).to.equal(0);\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/error-messages.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('Error messages', function() {\n  describe('first()', function() {\n    it('should return an error message that states the email is required', function() {\n      var validator = new Validator({\n        email: ''\n      }, {\n        email: 'required|email'\n      });\n      expect(validator.passes()).to.be.false;\n      expect(validator.errors.first('email')).to.equal('The email field is required.');\n    });\n\n    it('should have a method on the errors object to retrieve the first error message for an attribute', function() {\n      var validator = new Validator({\n        email: ''\n      }, {\n        email: 'required|email'\n      });\n      expect(validator.passes()).to.be.false;\n      expect(validator.errors.first('email')).to.equal('The email field is required.');\n    });\n\n    it('should return false if errors.first() is called and there are no errors', function() {\n      var validator = new Validator({\n        email: 'john@yahoo.com'\n      }, {\n        email: 'required|email'\n      });\n      expect(validator.passes()).to.be.true;\n      expect(validator.errors.first('email')).to.equal(false);\n    });\n\n    it('should return an error message that states the email must be valid', function() {\n      var validator = new Validator({\n        email: 'john@yahoo'\n      }, {\n        email: 'required|email'\n      });\n      expect(validator.passes()).to.be.false;\n      expect(validator.errors.first('email')).to.equal('The email format is invalid.');\n    });\n\n    it('should return null for a key without an error message', function() {\n      var validator = new Validator({\n        name: 'David'\n      }, {\n        name: 'required'\n      });\n      expect(validator.passes()).to.be.true;\n      expect(validator.errors.first('name')).to.be.false;\n    });\n\n    it('should return error messages with attribute names and values for multi-part rules', function() {\n      var validator = new Validator({\n        age: 17,\n        description: 'a',\n        info: '',\n        hours: 3,\n        pin: '123',\n        range: 20,\n        tweet: 'some tweet'\n      }, {\n        age: 'min:18',\n        description: 'required|min:5',\n        info: 'required|min:3',\n        hours: 'size:5',\n        pin: 'size:4',\n        range: 'max:10',\n        tweet: 'max:5'\n      });\n\n      expect(validator.passes()).to.be.false;\n      expect(validator.errors.first('age')).to.equal('The age must be at least 18.'); // min numeric\n      expect(validator.errors.first('description')).to.equal('The description must be at least 5 characters.'); // min string\n      expect(validator.errors.first('info')).to.equal('The info field is required.');\n      expect(validator.errors.first('hours')).to.equal('The hours must be 5.'); // size numeric\n      expect(validator.errors.first('pin')).to.equal('The pin must be 4 characters.'); // size string\n      expect(validator.errors.first('range')).to.equal('The range may not be greater than 10.'); // max numeric\n      expect(validator.errors.first('tweet')).to.equal('The tweet may not be greater than 5 characters.'); // max string\n    });\n\n    it('should return a customized alpha error message', function() {\n      var validator = new Validator({\n        name: '12'\n      }, {\n        name: 'alpha'\n      });\n      expect(validator.passes()).to.be.false;\n      expect(validator.errors.first('name')).to.equal('The name field must contain only alphabetic characters.');\n    });\n\n    it('should fail with non alpha dash characters', function() {\n      var validator = new Validator({\n        name: 'David *'\n      }, {\n        name: 'alpha_dash'\n      });\n      expect(validator.passes()).to.be.false;\n      expect(validator.errors.first('name')).to.equal('The name field may only contain alpha-numeric characters, as well as dashes and underscores.');\n    });\n\n    it('should fail without a matching confirmation field for the field under validation', function() {\n      var validator = new Validator({\n        password: 'abc'\n      }, {\n        password: 'confirmed'\n      });\n      expect(validator.passes()).to.be.false;\n      expect(validator.errors.first('password')).to.equal('The password confirmation does not match.');\n    });\n\n    it('should fail when the 2 attributes are the same', function() {\n      var validator = new Validator({\n        field1: 'abc',\n        field2: 'abc'\n      }, {\n        field2: 'different:field1'\n      });\n      expect(validator.passes()).to.be.false;\n      expect(validator.errors.first('field2')).to.equal('The field2 and field1 must be different.');\n    });\n\n    it('should fail with a url only containing http://', function() {\n      var link = 'http://';\n      var validator = new Validator({\n        link: link\n      }, {\n        link: 'url'\n      });\n      expect(validator.passes()).to.be.false;\n      expect(validator.errors.first('link')).to.equal('The link format is invalid.');\n    });\n\n    it('should fail the custom telephone rule registration with a default error message', function() {\n      Validator.register('telephone', function(val) {\n        return val.match(/^\\d{3}-\\d{3}-\\d{4}$/);\n      });\n\n      var validator = new Validator({\n        phone: '4213-454-9988'\n      }, {\n        phone: 'telephone'\n      });\n      expect(validator.passes()).to.be.false;\n      expect(validator.errors.first('phone')).to.equal('The phone attribute has errors.');\n    });\n\n    it('should fail the custom telephone rule registration with a custom error message', function() {\n      Validator.register('telephone', function(val) {\n        return val.match(/^\\d{3}-\\d{3}-\\d{4}$/);\n      }, 'The :attribute phone number is not in the format XXX-XXX-XXXX.');\n\n      var validator = new Validator({\n        cell: '4213-454-9988'\n      }, {\n        cell: 'telephone'\n      });\n      expect(validator.passes()).to.be.false;\n      expect(validator.errors.first('cell')).to.equal('The cell phone number is not in the format XXX-XXX-XXXX.');\n    });\n  });\n\n  describe('get()', function() {\n    it('should return an array of all email error messages', function() {\n      var validator = new Validator({\n        email: ''\n      }, {\n        email: 'required|email'\n      });\n\n      expect(validator.passes()).to.be.false;\n      expect(validator.errors.get('email')).to.be.instanceOf(Array);\n      expect(validator.errors.get('email').length).to.equal(1);\n    });\n\n    it('should return an empty array if there are no messages for an attribute', function() {\n      var validator = new Validator({\n        email: 'johndoe@gmail.com'\n      }, {\n        email: 'required|email'\n      });\n\n      expect(validator.passes()).to.be.true;\n      expect(validator.errors.get('email')).to.be.instanceOf(Array);\n      expect(validator.errors.get('email').length).to.equal(0);\n    });\n\n    it('should return multiple array items for an attribute', function() {\n\n      var validator = new Validator({\n        email: 'x'\n      }, {\n        email: 'email|min:10'\n      });\n\n      expect(validator.passes()).to.be.false;\n      expect(validator.errors.get('email')).to.be.instanceOf(Array);\n      expect(validator.errors.get('email').length).to.equal(2);\n\n    });\n\n  });\n\n\n  describe('ValidatorErrors.prototype.all()', function() {\n    it('should return an array of all email error messages', function() {\n      var validation = new Validator({\n        name: 'd',\n        email: '',\n        age: 28\n      }, {\n        name: 'required|min:2',\n        email: 'required|email',\n        age: 'min:18'\n      });\n\n      var expected = JSON.stringify({\n        name: ['The name must be at least 2 characters.'],\n        email: ['The email field is required.']\n      });\n\n      expect(validation.passes()).to.be.false;\n      expect(JSON.stringify(validation.errors.all())).to.equal(expected);\n    });\n  });\n\n  describe('ValidatorErrors.prototype.has()', function() {\n    it('should return an array of all email error messages', function() {\n      var validation = new Validator({\n        name: 'd',\n        email: '',\n        age: 28\n      }, {\n        name: 'required|min:2',\n        email: 'required|email',\n        age: 'min:18'\n      });\n\n      expect(validation.passes()).to.be.false;\n      expect(validation.errors.has('name')).to.equal(true);\n      expect(validation.errors.has('age')).to.equal(false);\n      expect(validation.errors.has('fake-property')).to.equal(false);\n    });\n  });\n\n  describe('should output correct error messages for numeric-like rules', function() {\n    it('should give correct error message with numeric rule', function() {\n      var validator = new Validator({\n        val: '1'\n      }, {\n        val: 'numeric|min:2'\n      });\n      expect(validator.fails()).to.be.true;\n      expect(validator.errors.first('val')).to.equal('The val must be at least 2.');\n    });\n\n    it('should give correct error message with integer rule', function() {\n      var validator = new Validator({\n        val: '1'\n      }, {\n        val: 'integer|min:2'\n      });\n      expect(validator.fails()).to.be.true;\n      expect(validator.errors.first('val')).to.equal('The val must be at least 2.');\n    });\n  });\n\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/flatten-object.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('Validator', function () {\n  context('_flattenObject', function() {\n    it('should correctly flatten nested object', function() {\n      var asserts = [\n        [undefined, {}],\n        [null, {}],\n        [{}, {}],\n        [{ foo: null }, { foo: null }],\n        [{ foo: {} }, { foo: {} }],\n        [{ foo : 1 }, { foo : 1 }],\n        [{ foo : [] }, { foo : [] }],\n        [{ foo: { bar: 1 } }, { 'foo.bar' : 1 }],\n        [{ foo: { bar: [] } }, { 'foo.bar' : [] }],\n        [{ foo: { bar: { fizz: \"buzz\" } } }, { 'foo.bar.fizz' : \"buzz\" }],\n        [{ foo: { bar: { fizz: [\"buzz\"] } } }, { 'foo.bar.fizz' : [\"buzz\"] }]\n      ];\n      var validator = new Validator({}, {});\n\n      asserts.forEach(function (assert) {\n        expect(validator._flattenObject(assert[0])).to.be.eql(assert[1]);\n      });\n    });\n  });\n}); // Page constructor\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/in-rule.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('in validation rule', function() {\n  it('should fail when the value is not in the set of comma separated values', function() {\n    var validator = new Validator({\n      state: 'fakeState',\n    }, {\n      state: 'in:CA,TX,FL'\n    });\n    expect(validator.passes()).to.be.false;\n    expect(validator.fails()).to.be.true;\n    expect(validator.errors.first('state')).to.equal('The selected state is invalid.');\n  });\n\n  it('should pass when the value is in the set of comma separated values', function() {\n    var validator = new Validator({\n      state: 'CA'\n    }, {\n      state: 'in:CA,TX,FL'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n  it('should pass when the value is undefined', function() {\n    var validator = new Validator({}, {\n      state: 'in:CA,TX,FL'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n  it('should pass when the value is an empty string', function() {\n    var validator = new Validator({\n      state: ''\n    }, {\n      state: 'in:CA,TX,FL'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n  it('should fail when the numeric value is not in the set of comma separated values', function() {\n    var validator = new Validator({\n      quantity: 10\n    }, {\n      quantity: 'in:0,1,2'\n    });\n    expect(validator.passes()).to.be.false;\n    expect(validator.fails()).to.be.true;\n    expect(validator.errors.first('quantity')).to.equal('The selected quantity is invalid.');\n  });\n\n  it('should pass when the value is in the set of comma separated values', function() {\n    var validator = new Validator({\n      quantity: 1\n    }, {\n      quantity: 'in:0,1,2'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n  it('should pass when all values are present', function() {\n    var validator = new Validator({\n      fruits: ['apple', 'strawberry']\n    }, {\n      fruits: 'array|in:apple,strawberry,kiwi'\n    });\n\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should fail when not all values are present', function() {\n    var validator = new Validator({\n      fruits: ['strawberry', 'kiwi']\n    }, {\n      fruits: 'array|in:apple,strawberry'\n    });\n\n    expect(validator.passes()).to.be.false;\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/integer-rule.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('integer pass rules', function() {\n  it('should pass if no value is entered', function() {\n    var validator = new Validator({}, {\n      age: 'integer'\n    });\n    expect(validator.fails()).to.be.false;\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should pass with an integer value', function() {\n    var validator = new Validator({\n      age: 18\n    }, {\n      age: 'integer'\n    });\n    expect(validator.fails()).to.be.false;\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should pass with a string containing an integer value', function() {\n    var validator = new Validator({\n      age: '18'\n    }, {\n      age: 'integer'\n    });\n    expect(validator.fails()).to.be.false;\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should pass with unsigned integer', function() {\n    var validator = new Validator({\n      num: -123\n    }, {\n      num: 'integer'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n});\n\ndescribe('integer fail rules', function() {\n\n  it('should fail with a decimal value', function() {\n    var validator = new Validator({\n      age: 18.9\n    }, {\n      age: 'integer'\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.passes()).to.be.false;\n    expect(validator.errors.first('age')).to.equal('The age must be an integer.')\n  });\n\n  it('should fail with a string value containing numbers and letters', function() {\n    var validator = new Validator({\n      age: '18d'\n    }, {\n      age: 'integer'\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.passes()).to.be.false;\n    expect(validator.errors.first('age')).to.equal('The age must be an integer.')\n  });\n\n  it('should fail with a boolean true value', function() {\n    var validator = new Validator({\n      age: true\n    }, {\n      age: 'integer'\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.passes()).to.be.false;\n  });\n\n  it('should fail with a boolean false value', function() {\n    var validator = new Validator({\n      age: false\n    }, {\n      age: 'integer'\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.passes()).to.be.false;\n  });\n\n  it('should fail if the value is an array', function() {\n    var validator = new Validator({\n      age: []\n    }, {\n      age: 'required|integer'\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.passes()).to.be.false;\n  });\n\n  it('should fail if the value is an object', function() {\n    var validator = new Validator({\n      age: {}\n    }, {\n      age: 'integer'\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.passes()).to.be.false;\n  });\n\n  it('should fail with unsigned float-integer', function() {\n    var validator = new Validator({\n      num: -70.36\n    }, {\n      num: 'integer'\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.passes()).to.be.false;\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/lang.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('lang / messages', function() {\n  it('should default to english', function() {\n    expect(Validator.getDefaultLang()).to.equal('en');\n  });\n\n  it('should be able to change lang', function() {\n    var oldLang = Validator.getDefaultLang();\n    Validator.useLang('ru');\n    expect(Validator.getDefaultLang()).to.equal('ru');\n    Validator.useLang(oldLang);\n  });\n\n  it('should be able to add custom', function() {\n    var oldLang = Validator.getDefaultLang();\n    var rawMessages = {\n      required: 'Le nkundla iyadingeka',\n      attributes: {}\n    };\n    Validator.setMessages('zu', rawMessages);\n    Validator.useLang('zu');\n    var validator = new Validator({\n      zip: ''\n    }, {\n      zip: 'required'\n    });\n\n    var messages = Validator.getMessages('zu');\n    expect(messages).to.equal(rawMessages);\n    expect(validator.fails()).to.be.true;\n    expect(validator.errors.first('zip')).to.equal('Le nkundla iyadingeka');\n    Validator.useLang(oldLang);\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/max-rule.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('max validation rule', function() {\n  it('should fail with the name \"David\". Maximum size is 3 letters.', function() {\n    var validator = new Validator({\n      name: 'David'\n    }, {\n      name: 'max:3'\n    });\n    expect(validator.passes()).to.be.false;\n  });\n\n  it('should pass with the name \"David\". Maximum size is 5 letters.', function() {\n    var validator = new Validator({\n      name: 'Da'\n    }, {\n      name: 'max:5'\n    });\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should fail with the age \"18\". Max is 12.', function() {\n    var validator = new Validator({\n      age: 18\n    }, {\n      age: 'max:12'\n    });\n    expect(validator.fails()).to.be.true;\n  });\n\n  it('should pass with the age \"12\". Max is 12.', function() {\n    var validator = new Validator({\n      age: 12\n    }, {\n      age: 'max:12'\n    });\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should fail with boolean true value', function() {\n    var validator = new Validator({\n      val: true\n    }, {\n      val: 'max:5'\n    });\n    expect(validator.fails()).to.be.true;\n  });\n\n  it('should fail with boolean false value', function() {\n    var validator = new Validator({\n      val: false\n    }, {\n      val: 'max:5'\n    });\n    expect(validator.fails()).to.be.true;\n  });\n\n  it('should pass when the age is 0', function() {\n    var validator = new Validator({\n      age: 0\n    }, {\n      age: 'max:2'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n  it('should pass when the field is an empty string', function() {\n    var validator = new Validator({\n      email: ''\n    }, {\n      email: 'max:2'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n  it('should pass when the field does not exist', function() {\n    var validator = new Validator({}, {\n      email: 'max:2'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n  it('should fail when given string-integer value', function() {\n    var validator = new Validator({\n      val: '18'\n    }, {\n      val: 'integer|max:16'\n    });\n    expect(validator.passes()).to.be.false;\n  });\n\n  it('should fail when given string-float value', function() {\n    var validator = new Validator({\n      val: '17.56'\n    }, {\n      val: 'numeric|max:17.5'\n    });\n    expect(validator.passes()).to.be.false;\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/nested-rules.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('nested validation rules', function() {\n  var nestedObject = {\n    name: 'required',\n    data: {\n      weight: 'required',\n      hair: {\n        color: 'required'\n      }\n    }\n  };\n\n  var nestedFlatten = {\n    name: 'required',\n    'data.weight': 'required',\n    'data.hair.color': 'required'\n  };\n\n  var dataPass = {\n    name: 'David',\n    data: {\n      weight: 70,\n      hair: {\n        color: 'black'\n      }\n    }\n  };\n\n  var failAsserts = [\n    [{}, {\n      name: 'The name field is required.',\n      'data.weight': 'The data.weight field is required.',\n      'data.hair.color': 'The data.hair.color field is required.'\n    }],\n    [{ name: 'David' }, {\n      'data.weight': 'The data.weight field is required.',\n      'data.hair.color': 'The data.hair.color field is required.'\n    }],\n    [{ data: { weight: 70 } }, {\n      name: 'The name field is required.',\n      'data.hair.color': 'The data.hair.color field is required.'\n    }],\n    [{ data: { hair: { color: 'black' } } }, {\n      name: 'The name field is required.',\n      'data.weight': 'The data.weight field is required.'\n    }]\n  ];\n\n  it('should pass with validation rules nested object', function() {\n    var validator = new Validator(dataPass, nestedObject);\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n  it('should fail with validation rules nested object', function() {\n    failAsserts.forEach(function (assert) {\n      var validator = new Validator(assert[0], nestedObject);\n      expect(validator.passes()).to.be.false;\n      expect(validator.fails()).to.be.true;\n      Object.keys(assert[1]).forEach(function (key) {\n        expect(validator.errors.first(key)).to.equal(assert[1][key]);\n      });\n    });\n  });\n\n  it('should pass with validation rules flatten object', function() {\n    var validator = new Validator(dataPass, nestedFlatten);\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n  it('should fail with validation rules flatten object', function() {\n    failAsserts.forEach(function (assert) {\n      var validator = new Validator(assert[0], nestedFlatten);\n      expect(validator.passes()).to.be.false;\n      expect(validator.fails()).to.be.true;\n      Object.keys(assert[1]).forEach(function (key) {\n        expect(validator.errors.first(key)).to.equal(assert[1][key]);\n      });\n    });\n  });\n}); // Page constructor\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/not_in-rule.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('not_in validation rule', function() {\n  it('should fail the value is in the set of comma separated values', function() {\n    var validator = new Validator({\n      username: 'skaterdav85'\n    }, {\n      username: 'not_in:skaterdav85,dtang,dtang85'\n    });\n    expect(validator.passes()).to.be.false;\n    expect(validator.fails()).to.be.true;\n    expect(validator.errors.first('username')).to.equal('The selected username is invalid.');\n  });\n\n  it('should pass when the value is not in the set of comma separated values', function() {\n    var validator = new Validator({\n      username: 'skatedav85'\n    }, {\n      username: 'not_in:user1,user2,user3'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n  it('should fail when the numeric value is in the set of comma separated values', function() {\n    var validator = new Validator({\n      id: 1\n    }, {\n      id: 'not_in:0,1,2'\n    });\n    expect(validator.passes()).to.be.false;\n    expect(validator.fails()).to.be.true;\n    expect(validator.errors.first('id')).to.equal('The selected id is invalid.');\n  });\n\n  it('should pass when the value is not in the set of comma separated values', function() {\n    var validator = new Validator({\n      id: 10\n    }, {\n      id: 'not_in:0,1,2'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n  it('should pass when the value is undefined', function() {\n    var validator = new Validator({}, {\n      country: 'not_in:China,Spain,France'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n  it('should pass when the value is an empty string', function() {\n    var validator = new Validator({\n      country: ''\n    }, {\n      country: 'not_in:China,Spain,France'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/numeric-rule.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('numeric validation rule', function() {\n  it('should pass with a numeric value', function() {\n    var validator = new Validator({\n      age: 44\n    }, {\n      age: 'numeric'\n    });\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should pass with a decimal numeric value', function() {\n    var validator = new Validator({\n      measurement: 0.5454\n    }, {\n      measurement: 'numeric'\n    });\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should pass with a string numeric value', function() {\n    var validator = new Validator({\n      age: '44'\n    }, {\n      age: 'numeric'\n    });\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should pass with a string decimal numeric value', function() {\n    var validator = new Validator({\n      measurement: '0.5454'\n    }, {\n      measurement: 'numeric'\n    });\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should fail with a string value', function() {\n    var validator = new Validator({\n      age: '18something'\n    }, {\n      age: 'numeric'\n    });\n    expect(validator.fails()).to.be.true;\n  });\n\n  it('should fail with a boolean true value', function() {\n    var validator = new Validator({\n      age: true\n    }, {\n      age: 'numeric'\n    });\n    expect(validator.fails()).to.be.true;\n  });\n\n  it('should fail with a boolean false value', function() {\n    var validator = new Validator({\n      age: false\n    }, {\n      age: 'numeric'\n    });\n    expect(validator.fails()).to.be.true;\n  });\n\n  it('should pass with no value', function() {\n    var validator = new Validator({}, {\n      age: 'numeric'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n  it('should pass with an empty string value', function() {\n    var validator = new Validator({\n      age: ''\n    }, {\n      age: 'numeric'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/passes.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('passes()', function() {\n  it('should not duplicate error messages when called multiple times', function() {\n    var validator = new Validator({}, {\n      login: 'required'\n    });\n\n    validator.passes();\n    validator.passes();\n\n    expect(validator.errors.all()).to.eql({\n      login: [\n        'The login field is required.'\n      ]\n    });\n  });\n\n  it('should work if the input doesn\\'t extend Object', function () {\n    // This happens in Express's req.body, for example.\n    var body = Object.create(null);\n    body.a = 2;\n\n    var validator = new Validator(body, {'a': 'required'});\n\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/present-rule.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('present validation rule', function() {\n  it('should pass with attribute present', function() {\n    var validator = new Validator({\n      email: 'name@domain.com',\n    }, {\n      email: 'present',\n    });\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should fail with attribute not present', function() {\n    var validator = new Validator({\n    }, {\n      email: 'present',\n    });\n    expect(validator.passes()).to.be.false;\n  });\n\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/regex-rule.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('regex validation rule for most common regular expressions', function() {\n  it('should pass with the currency pattern: 12,500.00', function() {\n    var validator = new Validator({\n      currency: '12,500.00'\n    }, {\n      currency: 'regex:/^(?!0\\\\.00)\\\\d{1,3}(,\\\\d{3})*(\\\\.\\\\d\\\\d)?$/'\n    });\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should fail with the currency pattern: 200.0', function() {\n    var validator = new Validator({\n      currency: '200.0'\n    }, {\n      currency: 'regex:/^(?!0\\\\.00)\\\\d{1,3}(,\\\\d{3})*(\\\\.\\\\d\\\\d)?$/'\n    });\n    expect(validator.fails()).to.be.true;\n  });\n\n  it('should pass with the date pattern: 03/11/2015', function() {\n    var validator = new Validator({\n      pattern: '03/11/2015'\n    }, {\n      pattern: ['regex:/^([1-9]|0[1-9]|[12][0-9]|3[01])\\\\D([1-9]|0[1-9]|1[012])\\\\D(19[0-9][0-9]|20[0-9][0-9])$/']\n    });\n    expect(validator.passes()).to.be.true;\n  });\n  it('should fail with the date pattern: 0311/2015', function() {\n    var validator = new Validator({\n      pattern: '0311/2015'\n    }, {\n      pattern: ['regex:/^([1-9]|0[1-9]|[12][0-9]|3[01])\\\\D([1-9]|0[1-9]|1[012])\\\\D(19[0-9][0-9]|20[0-9][0-9])$/']\n    });\n    expect(validator.fails()).to.be.true;\n  });\n\n  it('should pass with the year pattern: 2015', function() {\n    var validator = new Validator({\n      pattern: '2015'\n    }, {\n      pattern: ['regex:/^(19|20)[\\\\d]{2,2}$/']\n    });\n    expect(validator.passes()).to.be.true;\n  });\n  it('should fail with the year pattern:: 20151', function() {\n    var validator = new Validator({\n      pattern: '20151'\n    }, {\n      pattern: ['regex:/^(19|20)[\\\\d]{2,2}$/']\n    });\n    expect(validator.fails()).to.be.true;\n  });\n\n\n  it('should pass with the email pattern: johndoe@gmail.com', function() {\n    var validator = new Validator({\n      pattern: 'johndoe@gmail.com'\n    }, {\n      pattern: ['regex:/^(([^<>()[\\\\]\\\\\\.,;:\\\\s@\\\\\"]+(\\\\.[^<>()[\\]\\\\\\\\.,;:\\\\s@\\\\\"]+)*)|(\\\\\".+\\\\\"))@((\\\\[[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\\\\])|(([a-zA-Z\\\\-0-9]+\\\\.)+[a-zA-Z]{2,}))$/']\n    });\n    expect(validator.passes()).to.be.true;\n  });\n  it('should fail with the email pattern: johndoe.gmail.com', function() {\n    var validator = new Validator({\n      pattern: 'johndoe.gmail.com'\n    }, {\n      pattern: ['regex:/^(([^<>()[\\\\]\\\\\\.,;:\\\\s@\\\\\"]+(\\\\.[^<>()[\\]\\\\\\\\.,;:\\\\s@\\\\\"]+)*)|(\\\\\".+\\\\\"))@((\\\\[[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\\\\])|(([a-zA-Z\\\\-0-9]+\\\\.)+[a-zA-Z]{2,}))$/']\n    });\n    expect(validator.fails()).to.be.true;\n  });\n\n  it('should pass with the url pattern: http://github.com', function() {\n    var validator = new Validator({\n      pattern: 'http://github.com'\n    }, {\n      pattern: ['regex:/^https?:\\\\/\\\\/\\\\S+/']\n    });\n    expect(validator.passes()).to.be.true;\n  });\n  it('should fail with the url pattern: http://githubcom', function() {\n    var validator = new Validator({\n      pattern: 'http:/github.com'\n    }, {\n      pattern: ['regex:/^https?:\\\\/\\\\/\\\\S+/']\n    });\n    expect(validator.fails()).to.be.true;\n  });\n\n  it('should pass with the hex pattern: #ff0033', function() {\n    var validator = new Validator({\n      pattern: '#ff0033'\n    }, {\n      pattern: ['regex:/^#?([a-f0-9]{6}|[a-f0-9]{3})$/']\n    });\n    expect(validator.passes()).to.be.true;\n  });\n  it('should fail with the hex pattern: #xx9911', function() {\n    var validator = new Validator({\n      pattern: '#xx9911'\n    }, {\n      pattern: ['regex:/^#?([a-f0-9]{6}|[a-f0-9]{3})$/']\n    });\n    expect(validator.fails()).to.be.true;\n  });\n\n  it('should pass with the slug pattern: matching-a-slug-here', function() {\n    var validator = new Validator({\n      pattern: 'matching-a-slug-here'\n    }, {\n      pattern: ['regex:/^[a-z0-9-]+$/']\n    });\n    expect(validator.passes()).to.be.true;\n  });\n  it('should fail with the slug pattern: not_matching_here', function() {\n    var validator = new Validator({\n      pattern: 'not_matching_here'\n    }, {\n      pattern: ['regex:/^[a-z0-9-]+$/']\n    });\n    expect(validator.fails()).to.be.true;\n  });\n\n  it('should support the case insensitive flag', function () {\n    var validator = new Validator({\n      pattern: 'A'\n    }, {\n      pattern: ['regex:/[a-f]/i']\n    });\n\n    expect(validator.passes()).to.be.true;\n  })\n\n  it('should not be case insensitive unless specified', function() {\n    var validator = new Validator({\n      pattern: 'A'\n    }, {\n      pattern: ['regex:/[a-f]/']\n    });\n\n    expect(validator.fails()).to.be.true;\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/register.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('register a custom validation rule', function() {\n  it('should be able to get validation rule', function() {\n    Validator.register('telephone', function(val) {\n      return val.match(/^\\d{3}-\\d{3}-\\d{4}$/);\n    });\n\n    var validator = new Validator();\n    expect(validator.getRule('telephone').validate).to.be.a.function;\n  });\n\n  it('should pass the custom telephone rule registration', function() {\n    Validator.register('telephone', function(val) {\n      return val.match(/^\\d{3}-\\d{3}-\\d{4}$/);\n    });\n\n    var validator = new Validator({\n      phone: '213-454-9988'\n    }, {\n      phone: 'telephone'\n    });\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should override custom rules', function() {\n    Validator.register('string', function(val) {\n      return true;\n    });\n\n    var validator = new Validator({\n      field: ['not a string']\n    }, {\n      field: 'string'\n    });\n\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n    Validator.register('string', function(val) {\n      return typeof val === 'string';\n    }, 'The :attribute must be a string.');\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/required_if.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('required if', function() {\n  it('should fail', function() {\n    var validator = new Validator({\n      desert: 'icecream',\n      flavour: ''\n    }, {\n      flavour: 'required_if:desert,icecream'\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.passes()).to.be.false;\n    expect(validator.errors.first('flavour')).to.equal('The flavour field is required when desert is icecream.');\n  });\n\n  it('should pass', function() {\n    var validator = new Validator({\n      desert: 'icecream',\n      flavour: 'chocolate'\n    }, {\n      flavour: 'required_if:desert,icecream'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/required_unless.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('required unless', function() {\n  it('should fail', function() {\n    var validator = new Validator({\n      desert: 'icecream',\n      flavour: ''\n    }, {\n      flavour: 'required_unless:desert,cake'\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.passes()).to.be.false;\n    expect(validator.errors.first('flavour')).to.equal('The flavour field is required when desert is not cake.');\n  });\n\n  it('should pass', function() {\n    var validator = new Validator({\n      desert: 'icecream',\n      flavour: 'chocolate'\n    }, {\n      flavour: 'required_unless:desert,cake'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/required_with_all.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('required with all', function() {\n  it('should fail', function() {\n    var validator = new Validator({\n      desert: {\n        first: 'icecream',\n        second: 'icecream'\n      },\n      flavour: ''\n    }, {\n      flavour: 'required_with_all:desert.first,desert.second'\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.passes()).to.be.false;\n    expect(validator.errors.first('flavour')).to.equal('The flavour field is required when desert.first, desert.second are not empty.');\n  });\n\n  it('should pass', function() {\n    var validator = new Validator({\n      desert: {\n        first: 'icecream',\n        second: 'icecream'\n      },\n      flavour: 'chocolate'\n    }, {\n      flavour: 'required_with_all:desert.first,desert.second'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n  it('should pass (not all required field are set)', function() {\n    var validator = new Validator({\n      desert: {\n        first: 'icecream',\n      },\n      flavour: ''\n    }, {\n      flavour: 'required_with_all:desert.first,desert.second'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/required_with.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('required with', function() {\n  it('should fail', function() {\n    var validator = new Validator({\n      desert: {\n        first: 'icecream'\n      },\n      flavour: ''\n    }, {\n      flavour: 'required_with:desert.first'\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.passes()).to.be.false;\n    expect(validator.errors.first('flavour')).to.equal('The flavour field is required when desert.first is not empty.');\n  });\n\n  it('should pass', function() {\n    var validator = new Validator({\n      desert: {\n        first: 'icecream'\n      },\n      flavour: 'chocolate'\n    }, {\n      flavour: 'required_with:desert.first'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/required_without_all.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('required without all', function() {\n  it('should fail', function() {\n    var validator = new Validator({\n      flavour: ''\n    }, {\n      flavour: 'required_without_all:desert.first,desert.second'\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.passes()).to.be.false;\n    expect(validator.errors.first('flavour')).to.equal('The flavour field is required when desert.first, desert.second are empty.');\n  });\n\n  it('should pass', function() {\n    var validator = new Validator({\n      flavour: 'chocolate'\n    }, {\n      flavour: 'required_without_all:desert.first,desert.second'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n  it('should pass (not all required field are set)', function() {\n    var validator = new Validator({\n      desert: {\n        first: 'icecream',\n      },\n      flavour: ''\n    }, {\n      flavour: 'required_without_all:desert.first,desert.second'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/required_without.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('required without', function() {\n  it('should fail', function() {\n    var validator = new Validator({\n      desert: {\n        first: 'icecream'\n      },\n      flavour: ''\n    }, {\n      flavour: 'required_without:desert.second'\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.passes()).to.be.false;\n    expect(validator.errors.first('flavour')).to.equal('The flavour field is required when desert.second is empty.');\n  });\n\n  it('should pass', function() {\n    var validator = new Validator({\n      desert: {\n        first: 'icecream',\n        second: 'icecream'\n      },\n      flavour: ''\n    }, {\n      flavour: 'required_without:desert.second'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/require-rule.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('require validation pass rules', function() {\n  it('should pass with non-empty strings', function() {\n    var validator = new Validator({\n      name: 'David'\n    }, {\n      name: 'required'\n    });\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should fail with empty strings', function() {\n    var validator = new Validator({\n      email: ''\n    }, {\n      email: 'required'\n    });\n    expect(validator.fails()).to.be.true;\n  });\n\n  it('should fail with strings containing only white space', function() {\n    var validator = new Validator({\n      name: '      \t'\n    }, {\n      name: 'required'\n    });\n    expect(validator.fails()).to.be.true;\n  });\n\n  it('should fail when a value is equal to undefined', function() {\n    var validator = new Validator({\n      name: undefined\n    }, {\n      name: 'required'\n    });\n    expect(validator.fails()).to.be.true;\n  });\n\n  it('should fail when a value is equal to null', function() {\n    var validator = new Validator({\n      name: null\n    }, {\n      name: 'required'\n    });\n    expect(validator.fails()).to.be.true;\n  });\n\n  it('should pass when a value is numeric', function() {\n    var validator = new Validator({\n      age: 29\n    }, {\n      age: 'required'\n    });\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should fail when the attribute is not passed in', function() {\n    var validator = new Validator({}, {\n      email: 'required'\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.passes()).to.be.false;\n  });\n\n  it('should fail when the array is empty', function() {\n    var validator = new Validator({\n      users: []\n    }, {\n      users: 'required|array'\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.passes()).to.be.false;\n  });\n\n  it('should not fail when not an empty array', function() {\n    var validator = new Validator({\n      users: [false]\n    }, {\n      users: 'required|array'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/same-rule.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('same validation rule', function() {\n  it('should fail when the 2 attributes are different', function() {\n    var validator = new Validator({\n      pw: 'abc123',\n      pw2: 'abc1234'\n    }, {\n      pw2: 'same:pw'\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.passes()).to.be.false;\n    expect(validator.errors.first('pw2')).to.equal('The pw2 and pw fields must match.');\n  });\n\n  it('should fail when the the comparing attribute doesnt exist', function() {\n    var validator = new Validator({\n      pw2: 'abc1234'\n    }, {\n      pw2: 'same:pw'\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.passes()).to.be.false;\n    expect(validator.errors.first('pw2')).to.equal('The pw2 and pw fields must match.');\n  });\n\n  it('should pass when the 2 attributes are equal', function() {\n    var validator = new Validator({\n      pw: 'abc123',\n      pw2: 'abc123'\n    }, {\n      pw2: 'same:pw'\n    });\n    expect(validator.passes()).to.be.true;\n    expect(validator.fails()).to.be.false;\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/size-rule.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('size validation rule', function() {\n  it('should fail with the state = C. Size must be 2 letters.', function() {\n    var validator = new Validator({\n      state: 'C'\n    }, {\n      state: 'size:2'\n    });\n    expect(validator.fails()).to.be.true;\n  });\n\n  it('should pass with the state = CA. Size must be 2 letters.', function() {\n    var validator = new Validator({\n      state: 'CA'\n    }, {\n      state: 'size:2'\n    });\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should pass with an empty string', function() {\n    var validator = new Validator({\n      state: ''\n    }, {\n      state: 'size:2'\n    });\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should pass with the age 65. Size must be 65', function() {\n    var validator = new Validator({\n      age: 65\n    }, {\n      age: 'size:65'\n    });\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should fail with the age 64. Size must be 65.', function() {\n    var validator = new Validator({\n      age: 64\n    }, {\n      age: 'size:65'\n    });\n    expect(validator.fails()).to.be.true;\n  });\n\n  it('should pass when no value exists in the input object', function() {\n    var validator = new Validator({}, {\n      age: 'size:65'\n    });\n    expect(validator.fails()).to.be.false;\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should pass with string-integer', function() {\n    var validator = new Validator({\n      age: '65'\n    }, {\n      age: 'integer|size:65'\n    });\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should pass with float-integer', function() {\n    var validator = new Validator({\n      age: '65.36'\n    }, {\n      age: 'numeric|size:65.36'\n    });\n    expect(validator.passes()).to.be.true;\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/sometimes-rule.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('sometimes validation pass rules', function() {\n  it('should pass when the property is passed with data', function() {\n    var validator = new Validator({\n      firstname: 'Johnny',\n      lastname: 'Appleseed'\n    }, {\n      firstname: 'required',\n      lastname: 'required|sometimes'\n    });\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should pass when the property is not passed with data', function() {\n    var validator = new Validator({\n      firstname: 'Johnny'\n    }, {\n      firstname: 'required',\n      lastname: 'required|sometimes'\n    });\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should be able to register and pass async rule when the property is passed with data', function(done) {\n    Validator.registerAsync('username', function(desiredUsername, ruleValue, attribute, passes) {\n      setTimeout(function() {\n        if (desiredUsername == 'test') {\n          passes();\n        }\n      }, 50);\n    }, ':attribute is an invalid username');\n\n    var validator = new Validator({\n      username: 'test',\n      email: 'test@example.com'\n    }, {\n      username: 'username',\n      email: 'email|sometimes'\n    });\n    validator.passes(done);\n  });\n\n  it('should be able to register and pass async rule when the property is not passed with data', function(done) {\n    Validator.registerAsync('username', function(desiredUsername, ruleValue, attribute, passes) {\n      setTimeout(function() {\n        if (desiredUsername == 'test') {\n          passes();\n        }\n      }, 50);\n    }, ':attribute is an invalid username');\n\n    var validator = new Validator({\n      username: 'test'\n    }, {\n      username: 'username',\n      email: 'email|sometimes'\n    });\n    validator.passes(done);\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/stop-on-error.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('stopOnError tests', function() {\n  it('synchronous', function() {\n    var validator = new Validator({\n      email: 'x'\n    }, {\n      email: 'min:1|email'\n    });\n    validator.stopOnError(true);\n    expect(validator.fails()).to.be.true;\n    expect(validator.errors.get('email')).to.have.length(1);\n  });\n\n  // it('asynchronous', function(done) {\n\n  // \tValidator.registerAsync('username_available', function(val, ruleValue, attribute, passes) {\n  // \t\tthrow 'Should not have been called.';\n  // \t});\n  // \tvar validator = new Validator({ email: 'x' }, { email: 'email|username_available' });\n  // \tvalidator.stopOnError(true);\n  // \tvalidator.fails(function() {\n  // \t\texpect(validator.errors.get('email')).to.have.length(1);\n  // \t\tdone();\n  // \t});\n\n  // });\n\n  it('only certain fields', function() {\n    var validator = new Validator({\n      email1: 'x',\n      email2: 'x'\n    }, {\n      email1: 'min:5|email',\n      email2: 'min:5|email'\n    });\n    validator.stopOnError(['email2']);\n    expect(validator.fails()).to.be.true;\n    expect(validator.errors.get('email1')).to.have.length(2);\n    expect(validator.errors.get('email2')).to.have.length(1);\n  });\n\n  it('should allow globally setting whether to stop on error', function() {\n    Validator.stopOnError(true);\n    var validator = new Validator({\n      email: 'x'\n    }, {\n      email: 'min:5|email'\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.errors.get('email')).to.have.length(1);\n    Validator.stopOnError(false);\n  });\n\n  it('should always stop if field is implicit and cannot be validated', function() {\n    var validator = new Validator({\n      email: ''\n    }, {\n      email: 'required|email'\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.errors.get('email')).to.have.length(1);\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/string-rule.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('string validation rule', function() {\n  it('should pass when the input is a string', function() {\n    var validator = new Validator({\n      name: 'David'\n    }, {\n      name: 'string'\n    });\n\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should fail when the input is not a string', function() {\n    var validator = new Validator({\n      name: 5\n    }, {\n      name: 'string'\n    });\n\n    expect(validator.passes()).to.be.false;\n    expect(validator.errors.first('name')).to.equal('The name must be a string.');\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/url-rule.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('url validation rule', function() {\n  it('should fail with a url only containing http://', function() {\n    var link = 'http://';\n    var validator = new Validator({\n      link: link\n    }, {\n      link: 'url'\n    });\n    expect(validator.fails()).to.be.true;\n    expect(validator.passes()).to.be.false;\n  });\n\n  it('should pass with a url starting with http:// followed by 1 or more characters', function() {\n    var link = 'http://g';\n    var validator = new Validator({\n      link: link\n    }, {\n      link: 'url'\n    });\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should pass with an https url', function() {\n    var link = 'https://google.com';\n    var validator = new Validator({\n      link: link\n    }, {\n      link: 'url'\n    });\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should pass with an empty value', function() {\n    var validator = new Validator({\n      link: ''\n    }, {\n      link: 'url'\n    });\n    expect(validator.passes()).to.be.true;\n  });\n\n  it('should pass with an undefined value', function() {\n    var validator = new Validator({}, {\n      link: 'url'\n    });\n    expect(validator.passes()).to.be.true;\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/spec/validator.js":"if (typeof require !== 'undefined') {\n  var Validator = require('../src/validator.js');\n  var expect = require('chai').expect;\n} else {\n  var Validator = window.Validator;\n  var expect = window.chai.expect;\n}\n\ndescribe('Validator constructor', function() {\n  var validator;\n\n  beforeEach(function() {\n    validator = new Validator({\n      name: 'David',\n      email: 'johndoe@gmail.com'\n    }, {\n      name: 'required',\n      email: 'required'\n    }, {\n      required: \"You're missing :required\"\n    });\n  });\n\n  it('should expose on window if browser', function() {\n    if (typeof window !== 'undefined') {\n      expect(window.Validator).to.not.be.undefined;\n    }\n  });\n\n  it('should have a rules property containing all the validation rules', function() {\n    expect(validator.rules).to.be.a('object');\n  });\n\n  it('should have an input property containing the input data to be validated', function() {\n    expect(validator.input).to.be.a('object');\n  });\n\n  it('should have a messages property containing the combined messages for validation', function() {\n    expect(validator.messages).to.be.a('object');\n  });\n\n  it('should have a passes() method', function() {\n    expect(validator.passes).to.be.a.function;\n  });\n\n  it('should have a fails() method', function() {\n    expect(validator.fails).to.be.a.function;\n  });\n\n  it('should have a check method', function() {\n    expect(validator.check).to.be.a.function;\n  });\n}); // Page constructor\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/src/lang/de.js":"module.exports = {\n  accepted: 'Das :attribute Feld muss akzeptiert werden.',\n  after: 'Das :attribute muss ein Datum nach dem :after sein.',\n  after_or_equal: 'Das :attribute muss ein Datum gleich oder nach dem :after_or_equal sein.',\n  alpha: 'Das :attribute Feld darf nur aus Buchstaben bestehen.',\n  alpha_dash: 'Das :attribute Feld darf nur aus Buchstaben, Zahlen, Binde- und Unterstrichen bestehen',\n  alpha_num: 'Das :attribute Feld darf nur aus Buchstaben und Zahlen bestehen.',\n  before: 'Das :attribute muss ein Datum vor dem :before sein.',\n  before_or_equal: 'Das :attribute muss ein Datum gleich oder vor dem :before sein.',\n  between: 'Das :attribute Feld muss zwischen :min und :max liegen.',\n  confirmed: 'Das :attribute Feld stimmt nicht mit der Besttigung berein.',\n  email: 'Das :attribute Format ist ungltig.',\n  date: 'Das :attribute Feld muss ein gltiges Datum sein.',\n  def: 'Das :attribute Feld hat Fehler.',\n  digits: 'Das :attribute Feld muss :digits Stellen haben.',\n  different: 'Die Felder :attribute und :different mssen sich unterscheiden.',\n  'in': 'Der gewhlte Wert fr :attribute ist ungltig.',\n  integer: 'Das :attribute Feld muss eine ganze Zahl sein.',\n  min: {\n    numeric: 'Das :attribute Feld muss mindestens :min sein.',\n    string: 'Das :attribute Feld muss mindestens :min Zeichen lang sein.'\n  },\n  max: {\n    numeric: 'Das :attribute Feld darf maximal :max sein.',\n    string: 'Das :attribute Feld darf maximal :max Zeichen haben.'\n  },\n  not_in: 'Der gewhlte Wert fr :attribute ist ungltig.',\n  numeric: 'Das :attribute Feld muss eine Zahl sein.',\n  present: 'Das Feld :attribute muss vorhanden sein (kann aber leer sein).',\n  required: 'Das :attribute Feld muss ausgefllt sein.',\n  required_if: 'Das :attribute Feld muss ausgefllt sein, wenn :other :value ist.',\n  same: 'Die Felder :attribute und :same mssen bereinstimmen.',\n  size: {\n    numeric: 'Das :attribute Feld muss gleich :size sein.',\n    string: 'Das :attribute Feld muss :size Zeichen lang sein.'\n  },\n  string: 'Das :attribute Feld muss ein Satz sein.',\n  url: 'Das Format von :attribute ist ungltig.',\n  regex: 'Das :attribute Format ist ungltig.',\n  attributes: {}\n};\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/src/lang/el.js":"module.exports = {\n  accepted: '  :attribute    .',\n  after: '  :attribute        :after.',\n  alpha: '  :attribute     .',\n  alpha_dash: '  :attribute     , ,  .',\n  alpha_num: '  :attribute       .',\n  between: '  :attribute     :min  :max.',\n  confirmed: '   :attribute  .',\n  email: '  :attribute       email.',\n  date: '  :attribute    .',\n  def: '  :attribute  .',\n  digits: '  :attribute    :digits .',\n  different: '  :attribute   :different    .',\n  'in': '  :attribute   .',\n  integer: '  :attribute    .',\n  min: {\n    numeric: '  :attribute     :min.',\n    string: '  :attribute     :min .'\n  },\n  max: {\n    numeric: '  :attribute       :max.',\n    string: '  :attribute       :max .'\n  },\n  not_in: '  :attribute   .',\n  numeric: '  :attribute    .',\n  present: 'The :attribute field must be present (but can be empty).',\n  required: '  :attribute  .',\n  required_if: '  :attribute      :other  :value.',\n  same: '  :attribute  :same    .',\n  size: {\n    numeric: '  :attribute    :size.',\n    string: '  :attribute    :size .'\n  },\n  string: '  :attribute    .',\n  url: '  :attribute     URL.',\n  regex: '   :attribute   .',\n  attributes: {}\n};\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/src/lang/es.js":"module.exports = {\n  accepted: 'El campo :attribute debe ser aceptado.',\n  after: 'El campo :attribute debe ser una fecha posterior a :after.',\n  alpha: 'El campo :attribute solo debe contener letras.',\n  alpha_dash: 'El campo :attribute solo debe contener letras, nmeros y guiones.',\n  alpha_num: 'El campo :attribute solo debe contener letras y nmeros.',\n  attributes: {},\n  between: 'El campo :attribute tiene que estar entre :min - :max.',\n  confirmed: 'La confirmacin de :attribute no coincide.',\n  different: 'El campo :attribute y :other deben ser diferentes.',\n  digits: 'El campo :attribute debe tener :digits dgitos.',\n  email: 'El campo :attribute no es un correo vlido',\n  'in': 'El campo :attribute es invlido.',\n  integer: 'El campo :attribute debe ser un nmero entero.',\n  max: {\n    numeric: 'El campo :attribute no debe ser mayor a :max.',\n    string: 'El campo :attribute no debe ser mayor que :max caracteres.'\n  },\n  min: {\n    numeric: 'El tamao del campo :attribute debe ser de al menos :min.',\n    string: 'El campo :attribute debe contener al menos :min caracteres.'\n  },\n  not_in: 'El campo :attribute es invlido.',\n  numeric: 'El campo :attribute debe ser numrico.',\n  present: 'El campo de :attribute debe estar presente (pero puede estar vaco)',\n  regex: 'El formato del campo :attribute es invlido.',\n  required: 'El campo :attribute es obligatorio.',\n  required_if: 'El campo :attribute es obligatorio cuando :other es :value.',\n  same: 'El campo :attribute y :other deben coincidir.',\n  size: {\n    numeric: 'El tamao del campo :attribute debe ser :size.',\n    string: 'El campo :attribute debe contener :size caracteres.'\n  },\n  url: 'El formato de :attribute es invlido.'\n};\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/src/lang/fa.js":"module.exports = {\n  accepted: ' :attribute    ',\n  alpha: ' :attribute       ',\n  alpha_dash: ' :attribute            ',\n  alpha_num: ' :attribute        ',\n  between: ' :attribute     :min    :max ',\n  confirmed: '  :attribute   ',\n  email: '     :attribute  ',\n  date: '     :attribute  ',\n  def: ' :attribute  ',\n  digits: ' :attribute    :digits  ',\n  different: ' :attribute      :different  ',\n  'in': ' :attribute     ',\n  integer: ' :attribute    ',\n  min: {\n    numeric: ' :attribute    :min  ',\n    string: ' :attribute   :min    '\n  },\n  max: {\n    numeric: ' :attribute    :max  ',\n    string: ' :attribute    :max    '\n  },\n  not_in: ' :attribute     ',\n  numeric: ' :attribute    ',\n  present: 'The :attribute field must be present (but can be empty).',\n  required: ' :attribute  ',\n  required_if: '   :value  :other   :attribute  ',\n  same: ' :attribute     :same  ',\n  size: {\n    numeric: ' :attribute   :size ',\n    string: ' :attribute   :size    '\n  },\n  string: ' :attribute    ',\n  url: '  :attribute   ',\n  regex: '  :attribute   ',\n  attributes: {}\n};\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/src/lang/fr.js":"module.exports = {\n  accepted: 'Le champs :attribute doit tre accept.',\n  alpha: 'Le champs :attribute ne peut contenir que des caractres alphabtiques.',\n  alpha_dash: 'Le champs :attribute ne peut contenir que des caractres alphanumriques, des tirets et underscores.',\n  alpha_num: 'Le champs :attribute doit tre alphanumrique.',\n  between: 'Le champs :attribute doit tre compris entre :min and :max.',\n  confirmed: 'Le champs :attribute ne correspond pas.',\n  email: 'Le champs :attribute contient un format invalide.',\n  def: 'Le champs :attribute contient un attribut erron.',\n  digits: 'Le champs :attribute doit tre de :digits chiffres.',\n  different: 'Le champs :attribute et :different doivent tre differents.',\n  'in': 'Le champs :attribute est invalide.',\n  integer: 'Le champs :attribute doit tre un entier.',\n  min: {\n    numeric: 'Le champs :attribute doit tre contenir au moins :min.',\n    string: 'Le champs :attribute doit tre contenir au moins :min caractres.'\n  },\n  max: {\n    numeric: 'Le champs :attribute ne doit tre suprieur  :max.',\n    string: 'Le champs :attribute ne doit tre plus de :max characters.'\n  },\n  not_in: 'Le champs :attribute est invalide.',\n  numeric: 'Le champs :attribute doit tre un numro.',\n  present: 'Le champ :attribute doit tre prsent (mais peut tre vide).',\n  required: 'Le champs :attribute est obligatoire.',\n  required_if: 'Le champs :attribute est obligatoire quand :other est :value.',\n  same: 'Le champs :attribute et :same doivent correspondre.',\n  size: {\n    numeric: 'La taille du champs :attribute doit tre :size.',\n    string: 'La taille du champs :attribute doit tre de :size caractres.'\n  },\n  url: 'Le format du champs :attribute est invalide.',\n  regex: 'Le format du champs :attribute est invalide.',\n  attributes: {}\n};\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/src/lang/it.js":"module.exports = {\n  accepted: 'Il campo :attribute deve essere accettato.',\n  alpha: 'Il campo :attribute deve contenere sono caratteri alfabetici.',\n  alpha_dash: 'Il campo :attribute pu contenere solo caratteri alfanumerici oltre a trattini e trattini bassi.',\n  alpha_num: 'Il campo :attribute deve essere alfanumerico.',\n  between: 'Il campo :attribute deve essere compreso tra :min e :max.',\n  confirmed: 'Il campo conferma :attribute non  uguale.',\n  email: 'Il formato dell\\'attributo :attribute non  valido.',\n  def: 'Gli attributi del campo :attribute contengono degli errori.',\n  digits: 'Il campo :attribute deve essere di :digits cifre.',\n  different: 'Il campo :attribute e :different devo essere diversi.',\n  'in': 'Il valore del campo :attribute non  valido.',\n  integer: 'Il campo :attribute deve essere un valore intero.',\n  min: {\n    numeric: 'Il campo :attribute deve essere maggiore o uguale di :min.',\n    string: 'Il campo :attribute deve essere composto da almeno :min caratteri.'\n  },\n  max: {\n    numeric: 'Il campo :attribute deve essere minore o uguale di :max.',\n    string: 'Il campo :attribute deve essere composto da massimo :max caratteri.'\n  },\n  not_in: 'Il campo :attribute non  valido.',\n  numeric: 'Il campo :attribute deve essere un numero.',\n  present: 'Il campo :attribute deve essere presente (ma pu essere vuoto).',\n  required: 'Il campo :attribute  richiesto.',\n  required_if: 'Il campo :attribute  richiesto quando il campo :other  uguale a :value.',\n  same: 'I campi :attribute e :same devono essere uguali.',\n  size: {\n    numeric: 'La dimensione del campo :attribute deve essere uguale a :size.',\n    string: 'Il campo :attribute deve essere di :size caratteri.'\n  },\n  string: 'Il campo :attribute deve essere una stringa.',\n  url: 'Il formato del campo :attribute non  valido.',\n  regex: 'Il formato del campo :attribute non  valido.',\n  attributes: {}\n};\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/src/lang/ja.js":"module.exports = {\n    accepted: ':attribute',\n    alpha: ':attribute',\n    alpha_dash: ':attribute',\n    alpha_num: ':attribute',\n    between: ':attribute:min:max',\n    confirmed: ':attribute',\n    email: ':attribute',\n    date: ':attribute',\n    def: ':attribute',\n    digits: ':attribute:digits',\n    different: ':attribute:different',\n    'in': ':attribute',\n    integer: ':attribute',\n    min        : {\n        numeric : \":attribute:min\",\n        string  : \":attribute:min\"\n    },\n    max : {\n        numeric : \":attribute:max\",\n        string  : \":attribute:max\"\n    },\n    not_in      : \":attribute\",\n    numeric     : \":attribute\",\n    present: 'The :attribute field must be present (but can be empty).',\n    required    : \":attribute\",\n    required_if : \":other:value:attribute\",\n    same        : \":attribute:same\",\n    size        : {\n        numeric : \":attribute:size\",\n        string  : \":attribute:size\"\n    },\n    url        : \":attributeURI\",\n    regex      : \":attribute \\\":value\\\" \",\n    attributes : {}\n};\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/src/lang/nb_NO.js":"module.exports = {\n  accepted: ':attribute m vre akseptert.',\n  alpha: ':attribute feltet kan kun inneholde alfabetiske tegn.',\n  alpha_dash: ':attribute feltet kan kun inneholde alfanumeriske tegn, i tillegg til bindestreker og understreker.',\n  alpha_num: ':attribute feltet m vre alfanumerisk.',\n  between: ':attribute feltet m vre mellom :min og :max.',\n  confirmed: ':attribute feltet stemmer ikke overens med bekreftelsen.',\n  email: ':attribute formatet er ugyldig.',\n  date: ':attribute er et ugyldig datoformat.',\n  def: ':attribute attributtet har feil.',\n  digits: ':attribute m vre p :digits siffer.',\n  different: ':attribute og :different m vre forskjellige.',\n  'in': 'Den oppgitte verdien for :attribute er ugyldig.',\n  integer: ':attribute m vre et heltall.',\n  min: {\n    numeric: ':attribute m minst vre :min.',\n    string: ':attribute m vre p minst :min tegn.'\n  },\n  max: {\n    numeric: ':attribute kan ikke vre strre enn :max.',\n    string: ':attribute kan maks ha :max tegn.'\n  },\n  'not_in': 'Den oppgitte verdien for :attribute er ugyldig.',\n  numeric: ':attribute m vre et tall.',\n  present: 'The :attribute field must be present (but can be empty).',\n  required: ':attribute feltet er pkrevd.',\n  required_if: ':attribute er pkrevd nr :other er :value.',\n  same: ':attribute og :same m vre like.',\n  size: {\n    numeric: ':attribute m ha strrelsen :size.',\n    string: ':attribute m ha :size tegn.'\n  },\n  string: ':attribute m vre tekst.',\n  url: ':attribute formatet er ugyldig.',\n  regex: ':attribute formatet er ugyldig.',\n  attributes: {}\n};\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/src/lang/pl.js":"module.exports = {\n    accepted: 'Pole :attribute musi by zaakceptowane.',\n    alpha: 'Pole :attribute moe zawiera tylko litery.',\n    alpha_dash: 'Pole :attribute moze zawiera tylko litery, mylnik i podrkelenie.',\n    alpha_num: 'Pole :attribute moze zawierac tylko znaki alfanumeryczne.',\n    between: 'Pole :attribute musi mie dugo od :min do :max.',\n    confirmed: 'Pole :attribute nie spenia warunku potwierdzenia.',\n    email: 'Pole :attribute ma niepoprawny format adresu email.',\n    date: 'Pole :attribute musi mie poprawny format daty.',\n    def: 'Pole :attribute zawiera bdy.',\n    digits: 'Pole :attribute moe zawiera tylko cyfry ze zbioru :digits.',\n    different: 'Pola :attribute i :different musz si rni.',\n    'in': 'Pole :attribute musi nalee do zbioru :in.',\n    integer: 'Pole :attribute musi by liczb cakowit.',\n    min: {\n        numeric: 'Pole :attribute musi by rwne conajmniej :min.',\n        string: 'Pole :attribute musi zawiera conajmniej :min znakw.'\n    },\n    max: {\n        numeric: 'Pole :attribute nie moze by wiksze :max.',\n        string: 'Pole :attribute nie moze by dusze ni :max znakw.'\n    },\n    not_in: 'Pole :attribute nie moe nalee do zbioru :not_in.',\n    numeric: 'Pole :attribute musi by liczb.',\n    present: 'Polu :attribute musi by obecny (ale moe by pusta).',\n    required: 'Pole :attribute jest wymagane.',\n    required_if: 'Pole :attribute jest wymagane jeli pole :other jest rwne :value.',\n    same: 'Pola :attribute i :same musz by takie same.',\n    size: {\n        numeric: 'Pole :attribute musi by rwne :size.',\n        string: 'Pole :attribute musi zawiera :size znakw.'\n    },\n    string: 'Pole :attribute musi by cigiem znakw.',\n    url: 'Pole :attribute musi by poprawnym adresem URL.',\n    regex: 'Pole :attribute nie spenia warunku.',\n    attributes: {}\n};\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/src/lang/pt.js":"module.exports = {\n  accepted: 'O :attribute precisa ser aceito.',\n  alpha: 'O campo :attribute s pode conter letras.',\n  alpha_dash: 'O campo :attribute s pode conter letras, nmeros, hfens e sublinha.',\n  alpha_num: 'O campo :attribute s pode conter letras e nmeros.',\n  between: 'O campo :attribute precisa estar entre :min e :max.',\n  confirmed: 'A confirmao de :attribute no coincide.',\n  email: 'O formato de :attribute  invlido.',\n  date: 'O :attribute no  um formato de data vlido',\n  def: 'O atributo :attribute contm erros.',\n  digits: 'O atributo :attribute precisa ter :digits dgitos.',\n  different: 'O :attribute e :different precisam ser diferentes.',\n  'in': 'O atributo selecionado :attribute  invlido.',\n  integer: 'O :attribute precisa ser um inteiro.',\n  min: {\n    numeric: 'O :attribute precisa ser no mnimo :min.',\n    string: 'O :attribute precisa ter no mnimo :min caracteres.'\n  },\n  max: {\n    numeric: 'O :attribute no pode ser maior que :max.',\n    string: 'O :attribute no pode ter mais que :max caracteres.'\n  },\n  not_in: 'O :attribute selecionado  invlido.',\n  numeric: 'O :attribute precisa ser um nmero.',\n  present: 'O campo :attribute deve estar presente (mas pode estar vazio).',\n  required: 'O campo :attribute  obrigatrio.',\n  required_if: 'O campo :attribute  obrigatrio quando :other  :value.',\n  same: 'Os campos :attribute e :same precisam ser iguais.',\n  size: {\n    numeric: 'O :attribute precisa ser :size.',\n    string: 'O :attribute precisa ter :size caracteres.'\n  },\n  string: 'O :attribute precisa ser uma palavra.',\n  url: 'O formato de :attribute  invlido.',\n  regex: 'O formato de :attribute  invlido.',\n  attributes: {}\n};\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/src/lang/ru.js":"module.exports = {\n  accepted: '   :attribute.',\n  alpha: ' :attribute    .',\n  alpha_dash: ' :attribute    , ,    .',\n  alpha_num: ' :attribute      .',\n  between: ' :attribute    :min  :max.',\n  confirmed: ' :attribute    .',\n  email: ' :attribute     .',\n  def: ' :attribute  .',\n  digits: '   :attribute   :digits.',\n  different: ' :attribute  :different  .',\n  'in': '   :attribute .',\n  integer: ' :attribute    .',\n  min: {\n    numeric: '  :attribute      :min.',\n    string: '    :attribute     :min.'\n  },\n  max: {\n    numeric: '  :attribute      :max.',\n    string: '    :attribute    :max.'\n  },\n  not_in: '   :attribute .',\n  numeric: ' :attribute   .',\n  present: ' :attribute   (   ).',\n  required: ' :attribute   .',\n  required_if: ' :attribute     :other  :value.',\n  same: ' :attribute    :same.',\n  size: {\n    numeric: '  :attribute    :size.',\n    string: '    :attribute    :size.'\n  },\n  url: ' :attribute    URL.',\n  regex: '   :attribute.',\n  attributes: {}\n};\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/src/lang/tr.js":"module.exports = {\n  accepted: ':attribute kabul edilmeli.',\n  alpha: ':attribute alan sadece harflerden oluabilir.',\n  alpha_dash: ':attribute alan sadece alfa-nmerik, tire ve alt izgi karakterlerden oluabilir.',\n  alpha_num: ':attribute alan alfa-nmerik olmaldr.',\n  between: ':attribute alan :min ile :max arasnda olabilir.',\n  confirmed: ':attribute uyumuyor.',\n  email: ':attribute format geersiz.',\n  date: ':attribute geerli bir tarih alan deil.',\n  def: ':attribute hatalar ieriyor.',\n  digits: ':attribute sadece rakamlardan oluabilir.',\n  different: ':attribute ve :different farkl olmal.',\n  'in': 'Seilen :attribute geerli deil.',\n  integer: ':attribute tam say olmal.',\n  min: {\n    numeric: ':attribute en az :min olmal.',\n    string: ':attribute en az :min karakter uzunluunda olmal.'\n  },\n  max: {\n    numeric: ':attribute en ok :max olabilir.',\n    string: ':attribute uzunluu en ok :max karakter uzunluunda olabilir.'\n  },\n  not_in: 'Seilen :attribute geerli deil.',\n  numeric: ':attribute say olmal.',\n  present: ':attribute alan bulunmaldr (ancak bo olabilir).',\n  required: ':attribute alan gerekli.',\n  required_if: ':attribute alan :other alan :value olduunda gerekli.',\n  same: ':attribute ve :same ayn olmal.',\n  size: {\n    numeric: ':attribute :size olmal.',\n    string: ':attribute :size karakter uzunluunda olmal.'\n  },\n  string: ':attribute alfa-numerik olmal.',\n  url: ':attribute format geersiz.',\n  regex: ':attribute format geersiz.',\n  attributes: {}\n};\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/src/lang/vi.js":"module.exports = {\n  accepted: ':attribute phi c chp nhn.',\n  alpha: 'Trng :attribute phi l k t',\n  alpha_dash: ':attribute ch chp nhn k t ch ci, s, du gch cho v gch di.',\n  alpha_num: ':attribute phi l k t ch ci hoc ch s.',\n  between: ':attribute phi nm trong khong :min v :max.',\n  confirmed: ':attribute xc nhn khng trng khp.',\n  email: ':attribute khng phi l email.',\n  date: ':attribute khng phi l ngy hp l',\n  def: 'Thuc tnh :attribute c li.',\n  digits: ':attribute phi l s v c chiu di bng :digits.',\n  different: 'Gi tr ca hai trng :attribute v :different phi khc nhau.',\n  'in': 'Gi tr c chn ca :attribute khng hp l.',\n  integer: ':attribute phi l s nguyn.',\n  min: {\n    numeric: ':attribute phi ln hn hoc bng :min.',\n    string: ':attribute phi c t nht :min k t.'\n  },\n  max: {\n    numeric: ':attribute phi nh hn hoc bng :max.',\n    string: ':attribute phi c t hn :max k t.'\n  },\n  not_in: 'Gi tr c chn ca trng :attribute khng hp l.',\n  numeric: ':attribute phi l s.',\n  present: 'Trng :attribute phi c mt (nhng c th  trng).',\n  required: ':attribute bt buc nhp.',\n  required_if: ':attribute l bt buc khi :other c gi tr :value.',\n  same: 'Gi tr ca :attribute v :same phi nh nhau.',\n  size: {\n    numeric: ':attribute phi c chiu di ca bng :size.',\n    string: 'S k t ca :attribute phi l :size k t.'\n  },\n  string: ':attribute khng phi l mt chui',\n  url: ':attribute khng phi l mt Url hp l.',\n  regex: ':attribute khng ng nh dng',\n  attributes: {}\n};\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/src/lang/zh.js":"module.exports = {\n  accepted: ':attribute.',\n  alpha: ':attribute.',\n  alpha_dash: ':attribute,.',\n  alpha_num: ':attribute.',\n  between: ':attribute(,):min:max.',\n  confirmed: ':attribute.',\n  email: ':attribute.',\n  date: ':attribute.',\n  def: ':attribute.',\n  digits: ':attribute:digits.',\n  different: ':attribute:different.',\n  'in': ':attribute',\n  integer: ':attribute.',\n  min: {\n    numeric: ':attribute:min.',\n    string: ':attribute:min.'\n  },\n  max: {\n    numeric: ':attribute:max.',\n    string: ':attribute:max.'\n  },\n  not_in: ':attribute.',\n  numeric: ':attribute.',\n  present: 'The :attribute field must be present (but can be empty).',\n  required: ':attribute.',\n  required_if: ':other:value,:attribute.',\n  same: ':attribute:same.',\n  size: {\n    numeric: ':attribute:size.',\n    string: ':attribute:size.'\n  },\n  string: ':attribute.',\n  url: ':attribute.',\n  regex: ':attribute.',\n  attributes: {}\n};\n","/home/travis/build/npmtest/node-npmtest-validatorjs/node_modules/validatorjs/src/lang/zh_TW.js":"module.exports = {\n  accepted: ':attribute',\n  alpha: ':attribute',\n  alpha_dash: ':attribute',\n  alpha_num: ':attribute',\n  between: ':attribute:min:max',\n  confirmed: ':attribute',\n  email: ':attribute',\n  date: ':attribute',\n  def: ':attribute',\n  digits: ':attribute:digits',\n  different: ':attribute:different',\n  'in': ':attribute',\n  integer: ':attribute',\n  min: {\n    numeric: ':attribute:min',\n    string: ':attribute:min.'\n  },\n  max: {\n    numeric: ':attribute:max',\n    string: ':attribute:max.'\n  },\n  not_in: ':attribute',\n  numeric: ':attribute',\n  present: 'The :attribute field must be present (but can be empty).',\n  required: ':attribute',\n  required_if: ':other:value,:attribute',\n  same: ':attribute:same',\n  size: {\n    numeric: ':attribute:size',\n    string: ':attribute:size.'\n  },\n  string: ':attribute',\n  url: ':attribute',\n  regex: ':attribute',\n  attributes: {}\n};\n"}